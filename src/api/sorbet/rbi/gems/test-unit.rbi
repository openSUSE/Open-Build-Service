# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/test-unit/all/test-unit.rbi
#
# test-unit-3.3.3
module Test
end
module Test::Unit
end
class Object < BasicObject
  def run_test; end
end
class Test::Unit::AssertionFailedError < StandardError
  def actual; end
  def actual=(arg0); end
  def expected; end
  def expected=(arg0); end
  def initialize(message = nil, options = nil); end
  def inspected_actual; end
  def inspected_actual=(arg0); end
  def inspected_expected; end
  def inspected_expected=(arg0); end
  def user_message; end
  def user_message=(arg0); end
end
module Test::Unit::Util
end
module Test::Unit::Util::BacktraceFilter
  def filter_backtrace(backtrace, prefix = nil); end
  def self.filter_backtrace(backtrace, prefix = nil); end
end
module Test::Unit::Util::MethodOwnerFinder
  def find(object, method_name); end
  def self.find(object, method_name); end
end
module Test::Unit::Diff
  def diff(differ_class, from, to, options = nil); end
  def fold(string); end
  def folded_readable(from, to, options = nil); end
  def need_fold?(diff); end
  def readable(from, to, options = nil); end
  def self.diff(differ_class, from, to, options = nil); end
  def self.fold(string); end
  def self.folded_readable(from, to, options = nil); end
  def self.need_fold?(diff); end
  def self.readable(from, to, options = nil); end
  def self.unified(from, to, options = nil); end
  def unified(from, to, options = nil); end
end
class Test::Unit::Diff::SequenceMatcher
  def adjust_best_info_with_junk_predicate(should_junk, best_info, from_start, from_end, to_start, to_end); end
  def blocks; end
  def compute_blocks; end
  def compute_matches; end
  def compute_operations; end
  def compute_ratio; end
  def determine_tag(from_index, to_index, match_from_index, match_to_index); end
  def expand_edge_equal_operations!(_operations, context_size); end
  def find_best_match_position(from_start, from_end, to_start, to_end); end
  def grouped_operations(context_size = nil); end
  def initialize(from, to, &junk_predicate); end
  def longest_match(from_start, from_end, to_start, to_end); end
  def matches; end
  def operations; end
  def ratio; end
  def update_to_indexes; end
end
class Test::Unit::Diff::Differ
  def initialize(from, to); end
  def tag(mark, contents); end
end
class Test::Unit::Diff::UTF8Line
  def [](*args); end
  def compute_width(start, _end); end
  def each(&block); end
  def initialize(line); end
  def self.binary_search_ranges(character, ranges); end
  def self.wide_character?(character); end
  def size; end
  def to_s; end
end
class Test::Unit::Diff::ReadableDiffer < Test::Unit::Diff::Differ
  def _diff_lines(from_start, from_end, to_start, to_end); end
  def compute_width(line, start, _end); end
  def cut_off_ratio; end
  def default_ratio; end
  def diff(options = nil); end
  def diff_line(from_line, to_line); end
  def diff_lines(from_start, from_end, to_start, to_end); end
  def find_diff_line_info(from_start, from_end, to_start, to_end); end
  def format_diff_point(from_line, to_line, from_tags, to_tags); end
  def line_operations(from_line, to_line); end
  def n_leading_characters(string, character); end
  def operations; end
  def space_character?(character); end
  def tag(mark, contents); end
  def tag_deleted(contents); end
  def tag_difference(contents); end
  def tag_equal(contents); end
  def tag_inserted(contents); end
end
class Test::Unit::Diff::UnifiedDiffer < Test::Unit::Diff::Differ
  def define_line?(line); end
  def diff(options = nil); end
  def find_interesting_line(from_start, to_start, predicate); end
  def format_summary(operations, show_context); end
  def same_content?(groups); end
end
module Test::Unit::Assertions
  def _assert_in_delta_message(expected_float, actual_float, delta, message, options = nil); end
  def _assert_in_delta_validate_arguments(expected_float, actual_float, delta); end
  def _assert_in_epsilon_message(expected_float, actual_float, epsilon, message, options = nil); end
  def _assert_in_epsilon_validate_arguments(expected_float, actual_float, epsilon); end
  def _assert_raise(assert_expected_exception, *args, &block); end
  def _set_failed_information(failure, expected, actual); end
  def _wrap_assertion(&block); end
  def add_assertion; end
  def assert(object = nil, message = nil, &block); end
  def assert_alias_method(object, alias_name, original_name, message = nil); end
  def assert_block(message = nil); end
  def assert_boolean(actual, message = nil); end
  def assert_compare(expected, operator, actual, message = nil); end
  def assert_const_defined(object, constant_name, message = nil); end
  def assert_empty(object, message = nil); end
  def assert_equal(expected, actual, message = nil); end
  def assert_fail_assertion(message = nil); end
  def assert_false(actual, message = nil); end
  def assert_in_delta(expected_float, actual_float, delta = nil, message = nil); end
  def assert_in_epsilon(expected_float, actual_float, epsilon = nil, message = nil); end
  def assert_include(collection, object, message = nil); end
  def assert_includes(collection, object, message = nil); end
  def assert_instance_of(klass, object, message = nil); end
  def assert_kind_of(klass, object, message = nil); end
  def assert_match(pattern, string, message = nil); end
  def assert_nil(object, message = nil); end
  def assert_no_match(regexp, string, message = nil); end
  def assert_not_const_defined(object, constant_name, message = nil); end
  def assert_not_empty(object, message = nil); end
  def assert_not_equal(expected, actual, message = nil); end
  def assert_not_in_delta(expected_float, actual_float, delta = nil, message = nil); end
  def assert_not_in_epsilon(expected_float, actual_float, epsilon = nil, message = nil); end
  def assert_not_include(collection, object, message = nil); end
  def assert_not_includes(collection, object, message = nil); end
  def assert_not_instance_of(klass, object, message = nil); end
  def assert_not_kind_of(klass, object, message = nil); end
  def assert_not_match(regexp, string, message = nil); end
  def assert_not_nil(object, message = nil); end
  def assert_not_operator(object1, operator, object2, message = nil); end
  def assert_not_predicate(object, predicate, message = nil); end
  def assert_not_respond_to(object, method, message = nil); end
  def assert_not_same(expected, actual, message = nil); end
  def assert_not_send(send_array, message = nil); end
  def assert_nothing_raised(*args); end
  def assert_nothing_thrown(message = nil, &proc); end
  def assert_operator(object1, operator, object2, message = nil); end
  def assert_path_exist(path, message = nil); end
  def assert_path_not_exist(path, message = nil); end
  def assert_predicate(object, predicate, message = nil); end
  def assert_raise(*args, &block); end
  def assert_raise_kind_of(*args, &block); end
  def assert_raise_message(expected, message = nil); end
  def assert_raises(*args, &block); end
  def assert_respond_to(object, method, message = nil); end
  def assert_same(expected, actual, message = nil); end
  def assert_send(send_array, message = nil); end
  def assert_throw(expected_object, message = nil, &proc); end
  def assert_throws(expected_object, message = nil, &proc); end
  def assert_true(actual, message = nil); end
  def build_message(user_message, template = nil, *arguments); end
  def flunk(message = nil); end
  def refute(object, message = nil); end
  def refute_empty(object, message = nil); end
  def refute_equal(expected, actual, message = nil); end
  def refute_in_delta(expected_float, actual_float, delta = nil, message = nil); end
  def refute_in_epsilon(expected_float, actual_float, epsilon = nil, message = nil); end
  def refute_includes(collection, object, message = nil); end
  def refute_instance_of(klass, object, message = nil); end
  def refute_kind_of(klass, object, message = nil); end
  def refute_match(regexp, string, message = nil); end
  def refute_nil(object, message = nil); end
  def refute_operator(object1, operator, object2, message = nil); end
  def refute_predicate(object, predicate, message = nil); end
  def refute_respond_to(object, method, message = nil); end
  def refute_same(expected, actual, message = nil); end
  def self.use_pp=(value); end
end
class Test::Unit::Assertions::ThrowTagExtractor
  def extract_tag; end
  def initialize(error); end
  def normalize_tag(tag); end
end
class Test::Unit::Assertions::AssertionMessage
  def add_period(string); end
  def convert(object); end
  def initialize(user_message, template_string, parameters); end
  def self.convert(object); end
  def self.delayed_diff(from, to); end
  def self.delayed_literal(&block); end
  def self.diff_target_string?(string); end
  def self.ensure_diffable_string(string); end
  def self.literal(value); end
  def self.max_diff_target_string_size; end
  def self.max_diff_target_string_size=(size); end
  def self.maybe_container(value, &formatter); end
  def self.prepare_for_diff(from, to); end
  def self.use_pp; end
  def self.use_pp=(arg0); end
  def template; end
  def to_s; end
  def user_message; end
  include Test::Unit::Util::BacktraceFilter
end
class Test::Unit::Assertions::AssertionMessage::Inspector
  def <=>(other); end
  def initialize(object, inspected_objects = nil); end
  def inspect; end
  def inspect_target; end
  def native_inspect; end
  def object; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def self.cached_new(object, inspected_objects); end
  def self.inspector_classes; end
  def self.register_inspector_class(inspector_class); end
  def self.unregister_inspector_class(inspector_class); end
  include Comparable
end
class Test::Unit::Assertions::AssertionMessage::NumericInspector
  def initialize(numeric, inspected_objects); end
  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def self.target?(object); end
end
class Test::Unit::Assertions::AssertionMessage::HashInspector
  def each_pair; end
  def initialize(hash, inspected_objects); end
  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def self.target?(object); end
end
class Test::Unit::Assertions::AssertionMessage::ArrayInspector
  def each(&block); end
  def initialize(array, inspected_objects); end
  def inspect; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def self.target?(object); end
end
class Test::Unit::Assertions::AssertionMessage::Literal
  def initialize(value); end
  def inspect; end
end
class Test::Unit::Assertions::AssertionMessage::DelayedLiteral
  def initialize(value); end
  def inspect; end
end
class Test::Unit::Assertions::AssertionMessage::MaybeContainer
  def initialize(value, &formatter); end
  def inspect; end
end
class Test::Unit::Assertions::AssertionMessage::Template
  def concatenatable(text, encoding); end
  def count; end
  def initialize(parts); end
  def result(parameters); end
  def self.create(string); end
end
class Test::Unit::Assertions::AssertExceptionHelper
  def exception_class?(exception_type); end
  def exception_object?(exception_type); end
  def expected?(actual_exception, equality = nil); end
  def expected_class?(actual_exception, equality); end
  def expected_exceptions; end
  def expected_module?(actual_exception); end
  def expected_object?(actual_exception); end
  def fallback_exception_object_equal(expected_object, actual_exception); end
  def initialize(test_case, expected_exceptions); end
  def split_expected_exceptions(expected_exceptions); end
end
class Test::Unit::Assertions::AssertExceptionHelper::WrappedException
  def default_inspect?; end
  def exception; end
  def initialize(exception); end
  def inspect; end
  def method_missing(name, *args, &block); end
end
module Test::Unit::Attribute
  def [](name); end
  def attributes; end
  def self.included(base); end
end
class Test::Unit::Attribute::StringifyKeyHash < Hash
  def [](key); end
  def []=(key, value); end
  def key?(key); end
  def self.stringify(object); end
end
module Test::Unit::Attribute::BaseClassMethods
  def attributes_table; end
end
module Test::Unit::Attribute::ClassMethods
  def attribute(name, value, options = nil, *method_names); end
  def attribute_observers(attribute_name); end
  def attributes(method_name); end
  def attributes_table; end
  def current_attribute(name); end
  def current_attributes; end
  def find_attribute(method_name, name, options = nil); end
  def method_added(name); end
  def register_attribute_observer(attribute_name, observer = nil, &block); end
  def set_attributes(method_name, new_attributes); end
end
module Test::Unit::Fixture
  def create_fixtures_runner(fixtures, options, &block); end
  def run_cleanup; end
  def run_fixture(type, options = nil, &block); end
  def run_fixture_callback(method_name, options, &block); end
  def run_setup(&block); end
  def run_teardown; end
  def self.included(base); end
end
class Test::Unit::Fixture::Fixture
  def [](type); end
  def after_callbacks(type); end
  def before_callbacks(type); end
  def cleanup; end
  def collect_after_callbacks(type); end
  def collect_before_callbacks(type); end
  def collect_target_test_cases; end
  def initialize(test_case); end
  def merge_callbacks(prepend_callbacks, append_callbacks); end
  def setup; end
  def target_test_cases; end
  def teardown; end
end
class Test::Unit::Fixture::HookPoint
  def add_callback(method_name_or_callback, before_how, after_how); end
  def after_append_callbacks; end
  def after_prepend_callbacks; end
  def before_append_callbacks; end
  def before_prepend_callbacks; end
  def callback_method_name(callback); end
  def initialize(test_case, type, default_options); end
  def register(method_name_or_callback, options = nil); end
  def unregister(method_name_or_callback); end
  def valid_register_options?(options); end
end
module Test::Unit::Fixture::ClassMethods
  def cleanup(*method_names, &callback); end
  def fixture; end
  def register_fixture(fixture, *method_names, &callback); end
  def setup(*method_names, &callback); end
  def teardown(*method_names, &callback); end
  def unregister_cleanup(*method_names_or_callbacks); end
  def unregister_fixture(fixture, *method_names_or_callbacks); end
  def unregister_setup(*method_names_or_callbacks); end
  def unregister_teardown(*method_names_or_callbacks); end
end
module Test::Unit::ExceptionHandler
  def self.exception_handlers; end
  def self.included(base); end
end
module Test::Unit::ExceptionHandler::ClassMethods
  def exception_handler(*method_name_or_handlers, &block); end
  def exception_handlers; end
  def unregister_exception_handler(*method_name_or_handlers); end
end
class Test::Unit::Failure
  def actual; end
  def compute_diff; end
  def critical?; end
  def diff; end
  def expected; end
  def initialize(test_name, location, message, options = nil); end
  def inspected_actual; end
  def inspected_expected; end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def source_location; end
  def test_name; end
  def to_s; end
  def user_message; end
end
module Test::Unit::FailureHandler
  def add_failure(message, backtrace, options = nil); end
  def handle_assertion_failed_error(exception); end
  def self.included(base); end
end
module Test::Unit::TestResultFailureSupport
  def add_failure(failure); end
  def failure_count; end
  def failure_occurred?; end
  def failure_summary; end
  def failures; end
  def initialize_containers; end
end
class Test::Unit::Error
  def backtrace; end
  def critical?; end
  def exception; end
  def initialize(test_name, exception, options = nil); end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
  include Test::Unit::Util::BacktraceFilter
end
module Test::Unit::ErrorHandler
  def add_error(exception); end
  def handle_all_exception(exception); end
  def pass_through_exception?(exception); end
  def self.included(base); end
end
module Test::Unit::TestResultErrorSupport
  def add_error(error); end
  def error_count; end
  def error_occurred?; end
  def error_summary; end
  def errors; end
  def initialize_containers; end
end
class Test::Unit::Pending
  def critical?; end
  def initialize(test_name, location, message, options = nil); end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
  include Test::Unit::Util::BacktraceFilter
end
class Test::Unit::PendedError < StandardError
end
module Test::Unit::TestCasePendingSupport
  def add_pending(pending); end
  def pend(message = nil, &block); end
  def self.included(base); end
end
module Test::Unit::PendingHandler
  def handle_pended_error(exception); end
  def self.included(base); end
end
module Test::Unit::TestResultPendingSupport
  def add_pending(pending); end
  def initialize_containers; end
  def pending_count; end
  def pending_summary; end
  def pendings; end
end
class Test::Unit::Omission
  def critical?; end
  def initialize(test_name, location, message, options = nil); end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
  include Test::Unit::Util::BacktraceFilter
end
class Test::Unit::OmittedError < StandardError
end
module Test::Unit::TestCaseOmissionSupport
  def add_omission(omission); end
  def omit(message = nil, &block); end
  def omit_if(condition, *args, &block); end
  def omit_unless(condition, *args, &block); end
  def self.included(base); end
end
module Test::Unit::OmissionHandler
  def handle_omitted_error(exception); end
  def self.included(base); end
end
module Test::Unit::TestResultOmissionSupport
  def add_omission(omission); end
  def initialize_containers; end
  def omission_count; end
  def omission_summary; end
  def omissions; end
end
class Test::Unit::Notification
  def critical?; end
  def initialize(test_name, location, message, options = nil); end
  def label; end
  def location; end
  def long_display; end
  def message; end
  def method_name; end
  def short_display; end
  def single_character_display; end
  def test_name; end
  def to_s; end
  include Test::Unit::Util::BacktraceFilter
end
class Test::Unit::NotifiedError < StandardError
end
module Test::Unit::TestCaseNotificationSupport
  def add_notification(notification); end
  def notify(message, options = nil, &block); end
  def self.included(base); end
end
module Test::Unit::NotificationHandler
  def handle_notified_error(exception); end
  def self.included(base); end
end
module Test::Unit::TestResultNotificationSupport
  def add_notification(notification); end
  def initialize_containers; end
  def notification_count; end
  def notification_summary; end
  def notifications; end
end
module Test::Unit::Priority
  def priority_setup; end
  def priority_teardown; end
  def self.available_values; end
  def self.default; end
  def self.default=(default); end
  def self.disable; end
  def self.enable; end
  def self.enabled?; end
  def self.included(base); end
end
class Test::Unit::Priority::Checker
  def escape_class_name(class_name); end
  def escape_name(name); end
  def escaped_method_name; end
  def initialize(test); end
  def need_to_run?; end
  def passed_file; end
  def previous_test_success?; end
  def result_dir; end
  def self.available_priorities; end
  def self.have_priority?(name); end
  def self.need_to_run?(test); end
  def self.priority_check_method_name(priority_name); end
  def self.run_priority_high?(test); end
  def self.run_priority_important?(test); end
  def self.run_priority_low?(test); end
  def self.run_priority_must?(test); end
  def self.run_priority_never?(test); end
  def self.run_priority_normal?(test); end
  def setup; end
  def teardown; end
  def test; end
end
module Test::Unit::Priority::ClassMethods
  def priority(name, *tests); end
end
class Test::Unit::DataSets
  def <<(data_set); end
  def ==(other); end
  def add(data_set, options = nil); end
  def each; end
  def each_pattern(variables); end
  def each_raw_pattern(variables, &block); end
  def eql?(other); end
  def hash; end
  def initialize; end
  def keep; end
end
module Test::Unit::Data
  def self.included(base); end
end
module Test::Unit::Data::ClassMethods
  def data(*arguments, &block); end
  def load_data(file_name); end
end
class Test::Unit::Data::ClassMethods::Loader
  def initialize(test_case); end
  def load(file_name); end
  def load_csv(file_name); end
  def load_tsv(file_name); end
  def normalize_value(value); end
  def set_test_data(header, row); end
end
class Test::Unit::TestSuite
  def <<(test); end
  def ==(other); end
  def delete(test); end
  def delete_tests(tests); end
  def elapsed_time; end
  def empty?; end
  def handle_exception(exception, result); end
  def initialize(name = nil, test_case = nil); end
  def name; end
  def passed?; end
  def priority; end
  def priority=(arg0); end
  def run(result, &progress_block); end
  def run_shutdown(result); end
  def run_startup(result); end
  def run_test(test, result); end
  def size; end
  def start_time; end
  def test_case; end
  def tests; end
  def to_s; end
end
class Test::Unit::TestSuiteCreator
  def append_test(suite, test_name); end
  def collect_test_names; end
  def create; end
  def extract_data_sets(test_name); end
  def initialize(test_case); end
  def self.test_method?(test_case, method_name); end
  def sort_test_names_in_alphabetic_order(test_names); end
  def sort_test_names_in_defined_order(test_names); end
  def sort_test_names_in_random_order(test_names); end
end
module Test::Unit::AutoRunnerLoader
  def self.check(test_case, method_name); end
end
module Test::Unit::Util::Output
  def capture_output; end
end
class Test::Unit::TestCase
  def ==(other); end
  def add_assertion; end
  def add_pass; end
  def assign_test_data(label, data); end
  def cleanup; end
  def current_result; end
  def data; end
  def data_label; end
  def default_test; end
  def description; end
  def elapsed_time; end
  def handle_exception(exception); end
  def initialize(test_method_name); end
  def interrupted?; end
  def local_name; end
  def method_name; end
  def name; end
  def passed?; end
  def problem_occurred; end
  def run(result); end
  def run_test; end
  def self.add_method_location(location); end
  def self.added_method_names; end
  def self.description(value, target = nil); end
  def self.find_locations(query); end
  def self.include(*modules, &block); end
  def self.inherited(sub_class); end
  def self.method_added(name); end
  def self.method_locations; end
  def self.shutdown; end
  def self.startup; end
  def self.sub_test_case(name, &block); end
  def self.suite; end
  def self.target_method_locations(path); end
  def self.test(*test_description_or_targets, &block); end
  def self.test_defined?(query); end
  def self.test_order; end
  def self.test_order=(order); end
  def setup; end
  def size; end
  def start_time; end
  def teardown; end
  def to_s; end
  def valid?; end
  extend Test::Unit::Attribute::BaseClassMethods
  extend Test::Unit::Attribute::ClassMethods
  extend Test::Unit::Data::ClassMethods
  extend Test::Unit::ExceptionHandler::ClassMethods
  extend Test::Unit::Fixture::ClassMethods
  extend Test::Unit::Priority::ClassMethods
  include Test::Unit::Assertions
  include Test::Unit::Attribute
  include Test::Unit::Data
  include Test::Unit::ErrorHandler
  include Test::Unit::ExceptionHandler
  include Test::Unit::FailureHandler
  include Test::Unit::Fixture
  include Test::Unit::NotificationHandler
  include Test::Unit::OmissionHandler
  include Test::Unit::PendingHandler
  include Test::Unit::Priority
  include Test::Unit::TestCaseNotificationSupport
  include Test::Unit::TestCaseOmissionSupport
  include Test::Unit::TestCasePendingSupport
  include Test::Unit::Util::BacktraceFilter
  include Test::Unit::Util::Output
end
class Test::Unit::TestCase::InternalData
  def assign_test_data(label, data); end
  def elapsed_time; end
  def have_test_data?; end
  def initialize; end
  def interrupted; end
  def interrupted?; end
  def passed?; end
  def problem_occurred; end
  def start_time; end
  def test_data; end
  def test_data_label; end
  def test_finished; end
  def test_started; end
end
