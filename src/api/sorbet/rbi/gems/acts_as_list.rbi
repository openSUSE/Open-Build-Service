# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/acts_as_list/all/acts_as_list.rbi
#
# acts_as_list-0.9.19
module ActiveRecord
end
module ActiveRecord::Acts
end
module ActiveRecord::Acts::List
end
module ActiveRecord::Acts::List::ClassMethods
  def acts_as_list(options = nil); end
end
module ActiveRecord::Acts::List::InstanceMethods
  def acts_as_list_list; end
  def acts_as_list_order_argument(direction = nil); end
  def add_to_list_bottom; end
  def add_to_list_top; end
  def assume_bottom_position; end
  def assume_default_position?; end
  def assume_top_position; end
  def bottom_item(except = nil); end
  def bottom_position_in_list(except = nil); end
  def check_scope; end
  def check_top_position; end
  def clear_scope_changed; end
  def decrement_position; end
  def decrement_positions_on_higher_items(position); end
  def decrement_positions_on_lower_items(position = nil); end
  def default_position; end
  def default_position?; end
  def first?; end
  def higher_item; end
  def higher_items(limit = nil); end
  def in_list?; end
  def increment_position; end
  def increment_positions_on_all_items; end
  def increment_positions_on_higher_items; end
  def increment_positions_on_lower_items(position, avoid_id = nil); end
  def insert_at!(position = nil); end
  def insert_at(position = nil); end
  def insert_at_position(position, raise_exception_if_save_fails = nil); end
  def internal_scope_changed?; end
  def last?; end
  def lower_item; end
  def lower_items(limit = nil); end
  def move_higher; end
  def move_lower; end
  def move_to_bottom; end
  def move_to_top; end
  def move_within_scope(scope_id); end
  def not_in_list?; end
  def position_before_save; end
  def position_before_save_changed?; end
  def quoted_position_column; end
  def quoted_position_column_with_table_name; end
  def quoted_table_name; end
  def remove_from_list; end
  def scope_condition; end
  def set_list_position(new_position, raise_exception_if_save_fails = nil); end
  def shuffle_positions_on_intermediate_items(old_position, new_position, avoid_id = nil); end
  def swap_positions(item1, item2); end
  def update_positions; end
end
module ActiveRecord::Acts::List::PositionColumnMethodDefiner
  def self.call(caller_class, position_column, touch_on_update); end
  def self.define_class_methods(caller_class, position_column, touch_on_update); end
  def self.define_instance_methods(caller_class, position_column); end
  def self.mass_assignment_protection_was_used_by_user?(caller_class); end
  def self.protect_attributes_from_mass_assignment(caller_class, position_column); end
end
module ActiveRecord::Acts::List::ScopeMethodDefiner
  def self.call(caller_class, scope); end
  def self.idify(name); end
  extend ActiveSupport::Inflector
end
module ActiveRecord::Acts::List::TopOfListMethodDefiner
  def self.call(caller_class, top_of_list); end
end
module ActiveRecord::Acts::List::AddNewAtMethodDefiner
  def self.call(caller_class, add_new_at); end
end
module ActiveRecord::Acts::List::AuxMethodDefiner
  def self.call(caller_class); end
end
module ActiveRecord::Acts::List::CallbackDefiner
  def self.call(caller_class, add_new_at); end
end
module ActiveRecord::Acts::List::NoUpdate
  def act_as_list_no_update?; end
  def self.add_klass(klass); end
  def self.applied_to?(klass); end
  def self.apply_to(klasses); end
  def self.extracted_klasses; end
  def self.included(base); end
  def self.remove_klass(klass); end
end
class ActiveRecord::Acts::List::NoUpdate::ArrayTypeError < ArgumentError
  def initialize; end
end
class ActiveRecord::Acts::List::NoUpdate::DisparityClassesError < ArgumentError
  def initialize; end
end
module ActiveRecord::Acts::List::NoUpdate::ClassMethods
  def active_record_objects?(extra_classes); end
  def acts_as_list_no_update(extra_classes = nil, &block); end
end
module ActiveRecord::Acts::List::SequentialUpdatesMethodDefiner
  def self.call(caller_class, column, sequential_updates_option); end
end
class ActiveRecord::Base
  extend ActiveRecord::Acts::List::ClassMethods
end
