# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/thinking-sphinx/all/thinking-sphinx.rbi
#
# thinking-sphinx-4.3.2
class ThinkingSphinx::AttributeTypes
  def attributes; end
  def call; end
  def configuration; end
  def configuration_file; end
  def map_types_with_prefix(object, prefix, types); end
  def plain_sources; end
  def realtime_indices; end
  def self.call; end
  def self.reset; end
end
class ThinkingSphinx::BatchedSearch
  def contexts; end
  def initialize; end
  def populate(middleware = nil); end
  def populated?; end
  def searches; end
  def searches=(arg0); end
end
class ThinkingSphinx::Callbacks
  def initialize(instance); end
  def instance; end
  def self.callbacks(*methods); end
  def self.resume!; end
  def self.suspend!; end
  def self.suspend(&block); end
  def self.suspended?; end
end
module ThinkingSphinx::Core::Settings
  def apply_defaults!(defaults = nil); end
end
module ThinkingSphinx::Core::Field
  def infixing?; end
  def prefixing?; end
end
module ThinkingSphinx::Core::Index
  def assign_infix_fields; end
  def assign_prefix_fields; end
  def config; end
  def delta?; end
  def distributed?; end
  def document_id_for_instance(instance); end
  def document_id_for_key(key); end
  def initialize(reference, options = nil); end
  def interpret_definition!; end
  def model; end
  def name_suffix; end
  def options; end
  def path_prefix; end
  def pre_render; end
  def primary_key; end
  def render; end
  def set_path; end
  extend ActiveSupport::Concern
  include ThinkingSphinx::Core::Settings
end
class ThinkingSphinx::Core::Interpreter < BasicObject
  def initialize(index, block); end
  def method_missing(method, *args); end
  def search_option?(key); end
  def self.translate!(index, block); end
end
module ThinkingSphinx::Core::Property
  def facet?; end
  def multi?; end
  def type; end
end
module ThinkingSphinx::Core
end
module ThinkingSphinx::WithOutput
  def configuration; end
  def initialize(configuration, options = nil, stream = nil); end
  def options; end
  def stream; end
end
class ThinkingSphinx::Commander
  def self.call(command, configuration, options, stream = nil); end
  def self.registry; end
end
class ThinkingSphinx::Commands::Base
  def call_with_handling; end
  def command(command, extra_options = nil); end
  def command_output(output); end
  def controller(*args, &block); end
  def handle_failure(result); end
  def log(message); end
  def self.call(configuration, options, stream = nil); end
  def skip_directories?; end
  include ThinkingSphinx::WithOutput
end
class ThinkingSphinx::Commands::ClearRealTime < ThinkingSphinx::Commands::Base
  def binlog_path; end
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::ClearSQL < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::Configure < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::IndexSQL < ThinkingSphinx::Commands::Base
  def call; end
  def indices; end
  def type; end
end
class ThinkingSphinx::Commands::IndexRealTime < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::Merge < ThinkingSphinx::Commands::Base
  def call; end
  def controller(*args, &block); end
  def indices_exist?; end
  def type; end
end
class ThinkingSphinx::Commands::MergeAndUpdate < ThinkingSphinx::Commands::Base
  def call; end
  def controller(*args, &block); end
  def core_indices; end
  def delta_for(core_index); end
  def index_pairs; end
  def indices; end
  def indices_exist?(*indices); end
  def name_filters; end
  def type; end
end
class ThinkingSphinx::Commands::Prepare < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::Rotate < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::Running < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::StartAttached < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::StartDetached < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
class ThinkingSphinx::Commands::Stop < ThinkingSphinx::Commands::Base
  def call; end
  def type; end
end
module ThinkingSphinx::Commands
end
class ThinkingSphinx::Configuration::ConsistentIds
  def attributes; end
  def initialize(indices); end
  def reconcile; end
  def sources; end
  def sphinx_internal_ids; end
end
module ThinkingSphinx::Configuration::Defaults
end
class ThinkingSphinx::Configuration::DistributedIndices
  def append(index); end
  def distributed_index(reference, indices); end
  def grouped_indices; end
  def indices; end
  def initialize(indices); end
  def reconcile; end
end
class ThinkingSphinx::Configuration::DuplicateNames
  def counts_for(index); end
  def indices; end
  def initialize(indices); end
  def names_for(index); end
  def reconcile; end
end
class ThinkingSphinx::Configuration::MinimumFields
  def field_collections; end
  def indices; end
  def indices_of_type(type); end
  def initialize(indices); end
  def no_inheritance_columns?; end
  def reconcile; end
end
class ThinkingSphinx::Configuration < Riddle::Configuration
  def apply_sphinx_settings!; end
  def batch_size; end
  def batch_size=(arg0); end
  def bin_path; end
  def configuration_file; end
  def configuration_file=(arg0); end
  def configure_searchd; end
  def controller; end
  def controller=(arg0); end
  def engine_index_paths; end
  def engine_indice_paths; end
  def environment(*args, &block); end
  def framework; end
  def framework=(framework); end
  def guarding_strategy; end
  def guarding_strategy=(arg0); end
  def index_paths; end
  def index_set_class; end
  def index_set_class=(arg0); end
  def indexing_strategy; end
  def indexing_strategy=(arg0); end
  def indices_for_references(*references); end
  def indices_location; end
  def indices_location=(arg0); end
  def initialize; end
  def next_offset(reference); end
  def normalise; end
  def preload_index(file); end
  def preload_indices; end
  def render; end
  def render_to_file; end
  def reset; end
  def self.instance; end
  def self.reset; end
  def settings; end
  def setup; end
  def socket?; end
  def sphinx_sections; end
  def tcp?; end
  def verify; end
  def version; end
  def version=(arg0); end
end
class ThinkingSphinx::Connection::Client
  def check(statements); end
  def check_and_perform(statements); end
  def close!; end
  def close; end
  def close_and_clear; end
  def execute(statement); end
  def initialize(options); end
  def perform(statements); end
  def query_all(*statements); end
end
class ThinkingSphinx::Connection::JRuby < ThinkingSphinx::Connection::Client
  def address; end
  def base_error; end
  def client; end
  def initialize(options); end
  def options; end
  def properties; end
  def results_for(statements); end
  def set_to_array(set); end
end
class ThinkingSphinx::Connection::MRI < ThinkingSphinx::Connection::Client
  def base_error; end
  def client; end
  def options; end
  def results_for(statements); end
end
module ThinkingSphinx::Connection
  def self.connection_class; end
  def self.new; end
  def self.persistent=(persist); end
  def self.persistent?; end
  def self.pool; end
  def self.take; end
end
class ThinkingSphinx::Deletion
  def document_ids_for_keys; end
  def execute(statement); end
  def ids; end
  def index; end
  def initialize(index, ids); end
  def name(*args, &block); end
  def self.perform(index, ids); end
end
class ThinkingSphinx::Deletion::RealtimeDeletion < ThinkingSphinx::Deletion
  def callbacks_enabled?; end
  def configuration; end
  def perform; end
end
class ThinkingSphinx::Deletion::PlainDeletion < ThinkingSphinx::Deletion
  def perform; end
end
class ThinkingSphinx::SphinxError < StandardError
  def self.new_from_mysql(error); end
  def statement; end
  def statement=(arg0); end
end
class ThinkingSphinx::ConnectionError < ThinkingSphinx::SphinxError
end
class ThinkingSphinx::QueryError < ThinkingSphinx::SphinxError
end
class ThinkingSphinx::QueryLengthError < ThinkingSphinx::SphinxError
  def message; end
end
class ThinkingSphinx::SyntaxError < ThinkingSphinx::QueryError
end
class ThinkingSphinx::ParseError < ThinkingSphinx::QueryError
end
class ThinkingSphinx::OutOfBoundsError < ThinkingSphinx::QueryError
end
class ThinkingSphinx::QueryExecutionError < StandardError
  def statement; end
  def statement=(arg0); end
end
class ThinkingSphinx::MixedScopesError < StandardError
end
class ThinkingSphinx::NoIndicesError < StandardError
end
class ThinkingSphinx::MissingColumnError < StandardError
end
class ThinkingSphinx::PopulatedResultsError < StandardError
end
class ThinkingSphinx::DuplicateNameError < StandardError
end
class ThinkingSphinx::InvalidDatabaseAdapter < StandardError
end
class ThinkingSphinx::SphinxAlreadyRunning < StandardError
end
class ThinkingSphinx::UnknownDatabaseAdapter < StandardError
end
class ThinkingSphinx::UnknownAttributeType < StandardError
end
class ThinkingSphinx::TranscriptionError < StandardError
  def inner_exception; end
  def inner_exception=(arg0); end
  def instance; end
  def instance=(arg0); end
  def property; end
  def property=(arg0); end
end
class ThinkingSphinx::UnknownCommand < StandardError
end
class ThinkingSphinx::Excerpter
  def encoded?; end
  def excerpt!(text); end
  def index; end
  def index=(arg0); end
  def initialize(index, words, options = nil); end
  def options; end
  def options=(arg0); end
  def statement_for(text); end
  def words; end
  def words=(arg0); end
end
class ThinkingSphinx::Facet
  def filter_type; end
  def group_column; end
  def initialize(name, properties); end
  def name; end
  def results_from(raw); end
  def use_field?; end
end
class ThinkingSphinx::FacetSearch
  def [](key); end
  def configuration; end
  def each(&block); end
  def facet_names(facets); end
  def facets; end
  def for(facet_values); end
  def index_names_for(*facets); end
  def indices; end
  def initialize(query = nil, options = nil); end
  def limit; end
  def max_matches; end
  def options; end
  def options_for(facet); end
  def populate; end
  def populated?; end
  def properties; end
  def query; end
  def query=(arg0); end
  def to_hash; end
  include Enumerable
end
class ThinkingSphinx::FacetSearch::Filter
  def initialize(facets, hash); end
  def to_hash; end
end
class ThinkingSphinx::FloatFormatter
  def decimal_places; end
  def exponent_decimal_places; end
  def exponent_factor; end
  def exponent_present?; end
  def fixed; end
  def float; end
  def initialize(float); end
end
class ThinkingSphinx::Frameworks::Plain
  def environment; end
  def environment=(arg0); end
  def initialize; end
  def root; end
  def root=(arg0); end
end
class ThinkingSphinx::Frameworks::Rails
  def environment; end
  def root; end
end
module ThinkingSphinx::Frameworks
  def self.current; end
end
class ThinkingSphinx::Guard::File
  def initialize(name); end
  def lock; end
  def locked?; end
  def name; end
  def path; end
  def unlock; end
end
class ThinkingSphinx::Guard::Files
  def call(&block); end
  def initialize(names); end
  def log_lock(file); end
  def names; end
  def self.call(names, &block); end
  def unlocked; end
end
class ThinkingSphinx::Guard::None
  def self.call(names, &block); end
end
module ThinkingSphinx::Guard
end
class ThinkingSphinx::Hooks::GuardPresence
  def call; end
  def configuration; end
  def files; end
  def initialize(configuration = nil, stream = nil); end
  def self.call(configuration = nil, stream = nil); end
  def stream; end
end
class ThinkingSphinx::Index
  def block; end
  def delta_indices; end
  def index_class; end
  def indices; end
  def initialize(reference, options, &block); end
  def options; end
  def processor; end
  def reference; end
  def self.define(reference, options = nil, &block); end
  def single_index; end
end
class ThinkingSphinx::IndexingStrategies::AllAtOnce
  def self.call(indices = nil, &block); end
end
class ThinkingSphinx::IndexingStrategies::OneAtATime
  def self.call(indices = nil, &block); end
end
class ThinkingSphinx::IndexSet
  def all_indices; end
  def ancestors; end
  def classes; end
  def classes_and_ancestors; end
  def classes_specified?; end
  def configuration; end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def index_names; end
  def indices; end
  def indices_for_references; end
  def initialize(options = nil, configuration = nil); end
  def mti_classes; end
  def options; end
  def references; end
  def references_specified?; end
  def self.reference_name(klass); end
  def sti_classes; end
  def to_a; end
  include Enumerable
end
class ThinkingSphinx::Interfaces::Base
  def command(command, extra_options = nil); end
  include ThinkingSphinx::WithOutput
end
class ThinkingSphinx::Interfaces::Daemon < ThinkingSphinx::Interfaces::Base
  def controller(*args, &block); end
  def start; end
  def status; end
  def stop; end
end
class ThinkingSphinx::Interfaces::RealTime < ThinkingSphinx::Interfaces::Base
  def clear; end
  def index; end
  def index_names; end
  def indices; end
  def initialize(configuration, options, stream = nil); end
end
class ThinkingSphinx::Interfaces::SQL < ThinkingSphinx::Interfaces::Base
  def clear; end
  def filtered?; end
  def filtered_indices; end
  def index(reconfigure = nil, verbose = nil); end
  def index_names; end
  def indices; end
  def initialize(configuration, options, stream = nil); end
  def merge; end
end
module ThinkingSphinx::Interfaces
end
class ThinkingSphinx::Masks::GroupEnumeratorsMask
  def can_handle?(method); end
  def each_with_count(&block); end
  def each_with_group(&block); end
  def each_with_group_and_count(&block); end
  def initialize(search); end
end
class ThinkingSphinx::Masks::PaginationMask
  def can_handle?(method); end
  def count; end
  def first_page?; end
  def initialize(search); end
  def last_page?; end
  def next_page; end
  def next_page?; end
  def num_pages; end
  def page(number); end
  def page_count; end
  def per(limit); end
  def prev_page; end
  def previous_page; end
  def search; end
  def total_count; end
  def total_entries; end
  def total_pages; end
end
class ThinkingSphinx::Masks::ScopesMask
  def apply_scope(scope, *args); end
  def can_apply_scope?(scope); end
  def can_handle?(method); end
  def facets(query = nil, options = nil); end
  def initialize(search); end
  def method_missing(method, *args, &block); end
  def search(query = nil, options = nil); end
  def search_for_ids(query = nil, options = nil); end
  def sphinx_scopes; end
end
class ThinkingSphinx::Masks::WeightEnumeratorMask
  def can_handle?(method); end
  def each_with_weight(&block); end
  def initialize(search); end
end
module ThinkingSphinx::Masks
end
class ThinkingSphinx::Middlewares::Middleware
  def app; end
  def context; end
  def initialize(app); end
end
class ThinkingSphinx::Middlewares::ActiveRecordTranslator < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::ActiveRecordTranslator::Inner
  def call; end
  def context; end
  def ids_for_model(model_name); end
  def index_for(model); end
  def initialize(context); end
  def model_names; end
  def model_relation_with_sql_options(relation, model_sql_options); end
  def primary_key_for(model); end
  def reset_memos; end
  def result_for(row); end
  def results_for_models; end
  def sql_options; end
end
class ThinkingSphinx::Middlewares::Geographer < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::Geographer::Inner
  def call; end
  def context; end
  def fixed_format(float); end
  def geo(*args, &block); end
  def geodist_clause; end
  def geolocation_attributes; end
  def initialize(context); end
  def latitude(*args, &block); end
  def longitude(*args, &block); end
end
class ThinkingSphinx::Middlewares::Geographer::Inner::GeolocationAttributes
  def context; end
  def context=(arg0); end
  def geo; end
  def indices; end
  def initialize(context); end
  def latitude; end
  def latitude=(arg0); end
  def latitude_attr; end
  def longitude; end
  def longitude=(arg0); end
  def longitude_attr; end
  def names; end
  def search_context_options; end
end
class ThinkingSphinx::Middlewares::Glazier < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::Glazier::Inner
  def call; end
  def context; end
  def indices_for(model); end
  def initialize(context); end
  def row_for(result); end
end
class ThinkingSphinx::Middlewares::IdsOnly < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::Inquirer < ThinkingSphinx::Middlewares::Middleware
  def batch; end
  def call(contexts); end
  def combined_queries; end
end
class ThinkingSphinx::Middlewares::Inquirer::Inner
  def call(raw_results, meta_results); end
  def context; end
  def initialize(context); end
end
class ThinkingSphinx::Middlewares::SphinxQL < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::SphinxQL::Inner
  def call; end
  def class_condition; end
  def class_condition_required?; end
  def classes; end
  def classes_and_descendants; end
  def classes_and_descendants_names; end
  def classes_with_inheritance_column; end
  def configuration(*args, &block); end
  def constantize_inheritance_column(klass); end
  def context; end
  def descendants; end
  def descendants_from_tables; end
  def exclusive_filters; end
  def extended_query; end
  def group_attribute; end
  def group_order_clause; end
  def inclusive_filters; end
  def index_names; end
  def index_options; end
  def indices; end
  def indices_match_classes?; end
  def inheritance_column_select(klass); end
  def initialize(context); end
  def options(*args, &block); end
  def order_clause; end
  def search(*args, &block); end
  def select_options; end
  def settings(*args, &block); end
  def statement; end
  def values; end
end
class ThinkingSphinx::Middlewares::SphinxQL::Inner::Statement
  def filter_by_scopes; end
  def initialize(report); end
  def method_missing(*args, &block); end
  def query; end
  def query=(arg0); end
  def report; end
  def report=(arg0); end
  def scope_by_exclusive_filters; end
  def scope_by_extended_query; end
  def scope_by_from; end
  def scope_by_group; end
  def scope_by_inclusive_filters; end
  def scope_by_options; end
  def scope_by_order; end
  def scope_by_pagination; end
  def scope_by_values; end
  def scope_by_with_all; end
  def scope_by_without_all; end
  def to_riddle_query_select; end
end
class ThinkingSphinx::Middlewares::StaleIdChecker < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
end
class ThinkingSphinx::Middlewares::StaleIdChecker::Inner
  def actual_ids; end
  def call; end
  def context; end
  def expected_ids; end
  def initialize(context); end
  def raise_exception; end
  def stale_ids; end
end
class ThinkingSphinx::Middlewares::StaleIdFilter < ThinkingSphinx::Middlewares::Middleware
  def append_stale_ids(ids, context); end
  def call(contexts); end
  def log_message; end
  def stale_retries; end
end
class ThinkingSphinx::Middlewares::ValidOptions < ThinkingSphinx::Middlewares::Middleware
  def call(contexts); end
  def check_options(options); end
  def invalid_keys(keys); end
end
module ThinkingSphinx::Middlewares
  def self.use(builder, middlewares); end
end
class ThinkingSphinx::Panes::AttributesPane
  def initialize(context, object, raw); end
  def sphinx_attributes; end
end
class ThinkingSphinx::Panes::DistancePane
  def distance; end
  def geodist; end
  def initialize(context, object, raw); end
end
class ThinkingSphinx::Panes::ExcerptsPane
  def excerpt_words; end
  def excerpter; end
  def excerpts; end
  def initialize(context, object, raw); end
end
class ThinkingSphinx::Panes::ExcerptsPane::Excerpts
  def initialize(object, excerpter); end
  def method_missing(method, *args, &block); end
end
class ThinkingSphinx::Panes::WeightPane
  def initialize(context, object, raw); end
  def weight; end
end
module ThinkingSphinx::Panes
end
module ThinkingSphinx::Query
  def self.escape(query); end
  def self.wildcard(query, pattern = nil); end
end
class ThinkingSphinx::RakeInterface
  def configuration; end
  def configure; end
  def daemon; end
  def initialize(options = nil); end
  def options; end
  def rt; end
  def sql; end
end
module ThinkingSphinx::Scopes
  extend ActiveSupport::Concern
end
module ThinkingSphinx::Scopes::ClassMethods
  def default_sphinx_scope(scope_name = nil); end
  def method_missing(method, *args, &block); end
  def respond_to_missing?(method, include_private = nil); end
  def sphinx_scope(name, &block); end
  def sphinx_scopes; end
end
class ThinkingSphinx::Search::BatchInquirer
  def append_query(query); end
  def initialize(&block); end
  def results; end
end
class ThinkingSphinx::Search::Context
  def [](key); end
  def []=(key, value); end
  def configuration; end
  def initialize(search, configuration = nil); end
  def marshal_dump; end
  def marshal_load(array); end
  def search; end
end
class ThinkingSphinx::Search::Glaze < BasicObject
  def ==(object); end
  def equal?(object); end
  def initialize(context, object, raw = nil, pane_classes = nil); end
  def method_missing(method, *args, &block); end
  def respond_to?(method, include_private = nil); end
  def unglazed; end
end
class ThinkingSphinx::Search::Merger
  def initialize(search); end
  def merge!(query = nil, options = nil); end
  def search; end
end
class ThinkingSphinx::Search::Query
  def conditions; end
  def expand_key(key); end
  def initialize(keywords = nil, conditions = nil, star = nil); end
  def keywords; end
  def star; end
  def star_keyword(keyword, key = nil); end
  def to_s; end
end
class ThinkingSphinx::Search::StaleIdsException < StandardError
  def context; end
  def ids; end
  def initialize(ids, context); end
  def message; end
end
class ThinkingSphinx::Search < Array
  def context; end
  def current_page; end
  def default_middleware; end
  def initialize(query = nil, options = nil); end
  def limit_value(value = nil); end
  def marshal_dump; end
  def marshal_load(array); end
  def mask_stack; end
  def masks; end
  def masks_respond_to?(method); end
  def meta; end
  def method_missing(method, *args, &block); end
  def middleware; end
  def offset; end
  def offset_value; end
  def options; end
  def per_page(value = nil); end
  def populate; end
  def populated!; end
  def populated?; end
  def query; end
  def query=(arg0); end
  def query_time; end
  def raw; end
  def respond_to_missing?(method, include_private = nil); end
  def results_respond_to?(method, include_private = nil); end
  def self.valid_options; end
  def to_a; end
end
class ThinkingSphinx::Settings
  def absolute(relative); end
  def absolute_key?(key); end
  def call; end
  def configuration; end
  def defaults; end
  def file; end
  def file_keys; end
  def framework(*args, &block); end
  def initialize(configuration); end
  def join(first, last); end
  def merged; end
  def original; end
  def real_path(base, nonexistent = nil); end
  def self.call(configuration); end
end
class ThinkingSphinx::Subscribers::PopulatorSubscriber
  def call(message, *args); end
  def error(event); end
  def finish_populating(event); end
  def output(*args, &block); end
  def populated(event); end
  def print(*args, &block); end
  def puts(*args, &block); end
  def self.attach_to(namespace); end
  def start_populating(event); end
end
class ThinkingSphinx::Test
  def self.autostop; end
  def self.clear; end
  def self.config; end
  def self.index(*indexes); end
  def self.init(suppress_delta_output = nil); end
  def self.run(&block); end
  def self.start(options = nil); end
  def self.start_with_autostop; end
  def self.stop; end
end
class ThinkingSphinx::UTF8
  def encode; end
  def initialize(string); end
  def self.encode(string); end
  def string; end
end
class ThinkingSphinx::Wildcard
  def call; end
  def extended_pattern; end
  def initialize(query, pattern = nil); end
  def pattern; end
  def query; end
  def self.call(query, pattern = nil); end
end
class ThinkingSphinx::ActiveRecord::Property
  def columns; end
  def initialize(model, columns, options = nil); end
  def model; end
  def name; end
  def options; end
  def rebase(associations, options); end
  def source_type; end
  include ThinkingSphinx::Core::Property
end
class ThinkingSphinx::ActiveRecord::Association
  def initialize(column); end
  def stack; end
  def string?; end
  def to_s; end
end
class ThinkingSphinx::ActiveRecord::AssociationProxy::AttributeFinder
  def attribute; end
  def attributes; end
  def configuration; end
  def foreign_key; end
  def indices; end
  def initialize(association); end
  def reflection_target; end
end
class ThinkingSphinx::ActiveRecord::AssociationProxy::AttributeMatcher
  def attribute; end
  def attribute_name_matches?; end
  def column; end
  def column_name_matches?; end
  def foreign_key; end
  def initialize(attribute, foreign_key); end
  def many?; end
  def matches?; end
  def multi?(*args, &block); end
  def multi_singular_match?; end
  def name(*args, &block); end
end
module ThinkingSphinx::ActiveRecord::AssociationProxy
  def association_filter; end
  def normalise_search_arguments(query, options); end
  def perform_search(searcher); end
  def search(query = nil, options = nil); end
  def search_for_ids(query = nil, options = nil); end
  extend ActiveSupport::Concern
end
class ThinkingSphinx::ActiveRecord::Attribute::SphinxPresenter
  def collection_type; end
  def declaration; end
  def initialize(attribute, source); end
  def multi_declaration; end
  def query; end
  def sphinx_type; end
end
class ThinkingSphinx::ActiveRecord::Attribute::Type
  def associations; end
  def attribute; end
  def big_integer?; end
  def column_name; end
  def database_column; end
  def initialize(attribute, model); end
  def klass; end
  def model; end
  def multi?; end
  def multi_from_associations; end
  def single_column_reference?; end
  def timestamp?; end
  def type; end
  def type=(value); end
  def type_from_database; end
  def type_symbol; end
  def updateable?; end
end
class ThinkingSphinx::ActiveRecord::Attribute::Values
  def column; end
  def initialize(attribute); end
  def value_for(instance); end
end
class ThinkingSphinx::ActiveRecord::Attribute < ThinkingSphinx::ActiveRecord::Property
  def multi?(*args, &block); end
  def type(*args, &block); end
  def type=(arg); end
  def typist; end
  def updateable?(*args, &block); end
  def value_for(*args, &block); end
  def values; end
end
module ThinkingSphinx::ActiveRecord::Base
  extend ActiveSupport::Concern
end
module ThinkingSphinx::ActiveRecord::Base::ClassMethods
  def default_sphinx_scope?; end
  def default_sphinx_scope_response; end
  def facets(query = nil, options = nil); end
  def merge_search(search, query, options); end
  def search(query = nil, options = nil); end
  def search_count(query = nil, options = nil); end
  def search_for_ids(query = nil, options = nil); end
end
class ThinkingSphinx::ActiveRecord::Column
  def __name; end
  def __path; end
  def __replace(stack, replacements); end
  def __stack; end
  def initialize(*stack); end
  def method_missing(method, *args, &block); end
  def string?; end
  def to_ary; end
end
class ThinkingSphinx::ActiveRecord::ColumnSQLPresenter
  def __name(*args, &block); end
  def __stack(*args, &block); end
  def adapter; end
  def aggregate?; end
  def associations; end
  def column; end
  def escape_table(table_name); end
  def escape_table?; end
  def exists?; end
  def initialize(model, column, adapter, associations); end
  def model; end
  def path; end
  def string?(*args, &block); end
  def table; end
  def version; end
  def with_table; end
end
class ThinkingSphinx::ActiveRecord::DatabaseAdapters::AbstractAdapter
  def initialize(model); end
  def quote(column); end
  def quoted_table_name; end
  def utf8_query_pre; end
end
class ThinkingSphinx::ActiveRecord::DatabaseAdapters::MySQLAdapter < ThinkingSphinx::ActiveRecord::DatabaseAdapters::AbstractAdapter
  def boolean_value(value); end
  def cast_to_bigint(clause); end
  def cast_to_string(clause); end
  def cast_to_timestamp(clause); end
  def concatenate(clause, separator = nil); end
  def convert_blank(clause, default = nil); end
  def convert_nulls(clause, default = nil); end
  def group_concatenate(clause, separator = nil); end
  def settings; end
  def time_zone_query_pre; end
  def utf8_query_pre; end
end
class ThinkingSphinx::ActiveRecord::DatabaseAdapters::PostgreSQLAdapter < ThinkingSphinx::ActiveRecord::DatabaseAdapters::AbstractAdapter
  def boolean_value(value); end
  def cast_to_bigint(clause); end
  def cast_to_string(clause); end
  def cast_to_timestamp(clause); end
  def concatenate(clause, separator = nil); end
  def convert_blank(clause, default = nil); end
  def convert_nulls(clause, default = nil); end
  def group_concatenate(clause, separator = nil); end
  def time_zone_query_pre; end
end
module ThinkingSphinx::ActiveRecord::DatabaseAdapters
  def self.adapter_for(model); end
  def self.adapter_type_for(model); end
  def self.adapter_type_for_jdbc(model); end
  def self.adapter_type_for_jdbc_plain(adapter, url); end
  def self.default; end
  def self.default=(arg0); end
end
class ThinkingSphinx::ActiveRecord::Field < ThinkingSphinx::ActiveRecord::Property
  def file?; end
  def with_attribute?; end
  def wordcount?; end
  include ThinkingSphinx::Core::Field
end
class ThinkingSphinx::ActiveRecord::Index < Riddle::Configuration::Index
  def adapter; end
  def append_source; end
  def attributes; end
  def definition_block=(arg0); end
  def delta?; end
  def delta_processor; end
  def facets; end
  def fields; end
  def interpreter; end
  def name_suffix; end
  def offset; end
  def reference; end
  def source_options; end
  def sources; end
  def unique_attribute_names; end
  include ThinkingSphinx::Core::Index
end
class ThinkingSphinx::ActiveRecord::Interpreter < ThinkingSphinx::Core::Interpreter
  def __source; end
  def build_properties(klass, columns); end
  def define_source(&block); end
  def group_by(*columns); end
  def has(*columns); end
  def indexes(*columns); end
  def join(*columns); end
  def polymorphs(column, options); end
  def sanitize_sql(*arguments); end
  def set_database(hash_or_key); end
  def set_property(properties); end
  def source_option?(key); end
  def where(*conditions); end
end
class ThinkingSphinx::ActiveRecord::JoinAssociation < ActiveRecord::Associations::JoinDependency::JoinAssociation
  def build_constraint(klass, table, key, foreign_table, foreign_key); end
end
class ThinkingSphinx::ActiveRecord::LogSubscriber < ActiveSupport::LogSubscriber
end
class ThinkingSphinx::ActiveRecord::Polymorpher
  def append_reflections; end
  def class_names; end
  def clone_with(name, class_name); end
  def column; end
  def initialize(source, column, class_names); end
  def klass; end
  def mappings; end
  def morph!; end
  def morph_properties; end
  def morphed_stacks; end
  def reflection; end
  def source; end
end
class ThinkingSphinx::ActiveRecord::PropertyQuery
  def base_association; end
  def base_association_class; end
  def base_association_class_unscoped(*args, &block); end
  def column; end
  def extend_reflection(reflection); end
  def identifier; end
  def initialize(property, source, type = nil); end
  def joins; end
  def macros; end
  def offset; end
  def property; end
  def queries; end
  def quote_column(column); end
  def quote_with_table(table, column); end
  def quoted_foreign_key; end
  def quoted_primary_key; end
  def range_sql; end
  def ranged?; end
  def reflections; end
  def safe_habtm_column?; end
  def source; end
  def source_type; end
  def sql(*args, &block); end
  def to_s; end
  def to_sql; end
  def type; end
  def unsafe_habtm_column?; end
end
class ThinkingSphinx::ActiveRecord::PropertySQLPresenter
  def adapter; end
  def aggregate?; end
  def aggregate_separator; end
  def associations; end
  def cast_to_timestamp(clause); end
  def casted_column_with_table; end
  def column_presenters; end
  def columns_with_table; end
  def concatenate(clause); end
  def concatenating?; end
  def group?; end
  def initialize(property, adapter, associations); end
  def multi?(*args, &block); end
  def property; end
  def sourced_by_query?; end
  def to_group; end
  def to_select; end
end
class ThinkingSphinx::ActiveRecord::SimpleManyQuery < ThinkingSphinx::ActiveRecord::PropertyQuery
  def quoted_foreign_key; end
  def quoted_primary_key; end
  def range_sql; end
  def reflection; end
  def to_s; end
  def to_sql; end
end
class ThinkingSphinx::ActiveRecord::SourceJoins
  def append_column_associations(column); end
  def append_property_associations; end
  def append_specified_associations; end
  def call; end
  def column_exists?(column); end
  def column_included_in_queries?(column); end
  def initialize(model, source); end
  def joins; end
  def model; end
  def self.call(model, source); end
  def source; end
  def source_query_properties; end
end
module ThinkingSphinx
  def self.before_index_hooks; end
  def self.count(query = nil, options = nil); end
  def self.facets(query = nil, options = nil); end
  def self.output; end
  def self.rake_interface; end
  def self.rake_interface=(interface); end
  def self.search(query = nil, options = nil); end
  def self.search_for_ids(query = nil, options = nil); end
end
module ThinkingSphinx::ActiveRecord
end
class ThinkingSphinx::ActiveRecord::SQLBuilder::ClauseBuilder
  def add_clause(clause); end
  def clauses; end
  def compose(*additions); end
  def initialize(first_element); end
  def separated(by = nil); end
end
class ThinkingSphinx::ActiveRecord::SQLBuilder::Statement
  def attribute_presenters; end
  def custom_joins; end
  def field_presenters; end
  def filter_by_query_range; end
  def filter_by_scopes; end
  def group_clause; end
  def initialize(report); end
  def method_missing(*args, &block); end
  def minimal_group_by?; end
  def presenters_to_group(presenters); end
  def presenters_to_select(presenters); end
  def property_sql_presenter_for(property); end
  def property_sql_presenters_for(properties); end
  def report; end
  def scope; end
  def scope_by_custom_joins; end
  def scope_by_group_clause; end
  def scope_by_joins; end
  def scope_by_order; end
  def scope_by_select; end
  def scope_by_where_clause; end
  def select_clause; end
  def source; end
  def to_query_pre; end
  def to_query_range_relation; end
  def to_relation; end
  def where_clause(for_range = nil); end
end
class ThinkingSphinx::ActiveRecord::SQLBuilder::Query
  def filter_by_query_pre; end
  def initialize(report); end
  def method_missing(*args, &block); end
  def report; end
  def report=(arg0); end
  def scope; end
  def scope=(arg0); end
  def scope_by_delta_processor; end
  def scope_by_session; end
  def scope_by_time_zone; end
  def scope_by_utf8; end
  def source; end
  def to_query; end
end
class ThinkingSphinx::ActiveRecord::SQLBuilder
  def adapter(*args, &block); end
  def associations; end
  def big_document_ids?; end
  def cast_to_bigint(*args, &block); end
  def config; end
  def convert_nulls(*args, &block); end
  def delta_processor(*args, &block); end
  def document_id; end
  def groupings; end
  def initialize(source); end
  def model(*args, &block); end
  def model_name; end
  def pre_select; end
  def query; end
  def quote_column(column); end
  def quoted_inheritance_column; end
  def quoted_primary_key; end
  def range_condition; end
  def relation; end
  def source; end
  def sql_query; end
  def sql_query_pre; end
  def sql_query_range; end
  def statement; end
  def time_zone_query_pre(*args, &block); end
  def utf8_query_pre(*args, &block); end
end
class ThinkingSphinx::ActiveRecord::SQLSource::Template
  def add_attribute(column, name, type, options = nil); end
  def add_field(column, name, options = nil); end
  def apply; end
  def class_column; end
  def inheriting?; end
  def initialize(source); end
  def model; end
  def primary_key; end
  def source; end
end
class ThinkingSphinx::ActiveRecord::SQLSource < Riddle::Configuration::SQLSource
  def adapter; end
  def append_presenter_to_attribute_array; end
  def associations; end
  def associations=(arg0); end
  def attribute_array_for(type); end
  def attributes; end
  def attributes=(arg0); end
  def build_sql_fields; end
  def build_sql_query; end
  def builder; end
  def conditions; end
  def conditions=(arg0); end
  def config; end
  def database_settings; end
  def delta?; end
  def delta_processor; end
  def disable_range?; end
  def facets; end
  def fields; end
  def fields=(arg0); end
  def groupings; end
  def groupings=(arg0); end
  def initialize(model, options = nil); end
  def model; end
  def offset; end
  def options; end
  def polymorphs; end
  def polymorphs=(arg0); end
  def prepare_for_render; end
  def primary_key; end
  def properties; end
  def render; end
  def set_database_settings(settings); end
  def type; end
  include ThinkingSphinx::Core::Settings
end
class ThinkingSphinx::ActiveRecord::Callbacks::DeleteCallbacks < ThinkingSphinx::Callbacks
  def after_destroy; end
  def after_rollback; end
  def delete_from_sphinx; end
  def indices; end
  extend Anonymous_Module_24
end
module Anonymous_Module_24
  def after_destroy(instance); end
  def after_rollback(instance); end
end
class ThinkingSphinx::ActiveRecord::Callbacks::DeltaCallbacks < ThinkingSphinx::Callbacks
  def after_commit; end
  def before_save; end
  def config; end
  def core_indices; end
  def delta_indices; end
  def delta_indices?; end
  def indices; end
  def new_or_changed?; end
  def processors; end
  def suspended?; end
  def toggled?; end
  extend Anonymous_Module_25
end
module Anonymous_Module_25
  def after_commit(instance); end
  def before_save(instance); end
end
class ThinkingSphinx::ActiveRecord::Callbacks::UpdateCallbacks < ThinkingSphinx::Callbacks
  def after_update; end
  def attributes_hash_for(index); end
  def changed_attributes; end
  def configuration; end
  def indices; end
  def reference; end
  def update(index); end
  def updateable_attributes_for(index); end
  def updates_enabled?; end
  extend Anonymous_Module_26
end
module Anonymous_Module_26
  def after_update(instance); end
end
class ThinkingSphinx::ActiveRecord::Depolymorph::BaseReflection
  def call; end
  def class_name; end
  def initialize(reflection, name, class_name); end
  def klass; end
  def name; end
  def options; end
  def reflection; end
end
class ThinkingSphinx::ActiveRecord::Depolymorph::AssociationReflection < ThinkingSphinx::ActiveRecord::Depolymorph::BaseReflection
  def call; end
  def explicit_macro?; end
  def options; end
end
class ThinkingSphinx::ActiveRecord::Depolymorph::ConditionsReflection < ThinkingSphinx::ActiveRecord::Depolymorph::BaseReflection
  def active_record(*args, &block); end
  def call; end
  def condition; end
  def foreign_type(*args, &block); end
  def options; end
  def quoted_foreign_type; end
end
class ThinkingSphinx::ActiveRecord::Depolymorph::OverriddenReflection < ThinkingSphinx::ActiveRecord::Depolymorph::BaseReflection
  def call; end
  def extension(reflection); end
  def klass; end
  def self.overridden_classes; end
end
module ThinkingSphinx::ActiveRecord::Depolymorph::OverriddenReflection::BuildJoinConstraint
  def build_join_constraint(table, foreign_table); end
end
module ThinkingSphinx::ActiveRecord::Depolymorph::OverriddenReflection::JoinScope
  def join_scope(table, foreign_table, foreign_klass); end
end
class ThinkingSphinx::ActiveRecord::Depolymorph::ScopedReflection < ThinkingSphinx::ActiveRecord::Depolymorph::BaseReflection
  def call; end
  def scope; end
end
class ThinkingSphinx::ActiveRecord::FilterReflection
  def self.call(reflection, name, class_name); end
end
module ThinkingSphinx::ActiveRecord::Callbacks
end
module ThinkingSphinx::ActiveRecord::Depolymorph
end
class ThinkingSphinx::Deltas::DefaultDelta
  def adapter; end
  def clause(delta_source = nil); end
  def column; end
  def config; end
  def controller; end
  def delete(index, instance); end
  def index(index); end
  def initialize(adapter, options = nil); end
  def options; end
  def quoted_column; end
  def reset_query; end
  def toggle(instance); end
  def toggled?(instance); end
end
class ThinkingSphinx::Deltas::DeleteJob
  def initialize(index_name, document_id); end
  def perform; end
  def statement; end
end
class ThinkingSphinx::Deltas::IndexJob
  def configuration; end
  def index_name; end
  def initialize(index_name); end
  def perform; end
  def quiet_deltas?; end
end
module ThinkingSphinx::Deltas
  def self.config; end
  def self.processor_for(delta); end
  def self.resume!; end
  def self.suspend!; end
  def self.suspend(reference, &block); end
  def self.suspend_and_update(reference, &block); end
  def self.suspended?; end
end
class ThinkingSphinx::Distributed::Index < Riddle::Configuration::DistributedIndex
  def configuration; end
  def delta?; end
  def distributed?; end
  def facets; end
  def initialize(reference); end
  def local_index_objects; end
  def local_index_objects=(indices); end
  def model; end
  def options; end
  def primary_key; end
  def reference; end
end
module ThinkingSphinx::Distributed
end
class ThinkingSphinx::Logger
  def self.log(notification, message, &block); end
end
class ThinkingSphinx::RealTime::Property
  def column; end
  def initialize(column, options = nil); end
  def name; end
  def options; end
  def translate(object); end
  include ThinkingSphinx::Core::Property
end
class ThinkingSphinx::RealTime::Attribute < ThinkingSphinx::RealTime::Property
  def default_value; end
  def json?; end
  def multi?; end
  def translate(object); end
  def type; end
end
class ThinkingSphinx::RealTime::Field < ThinkingSphinx::RealTime::Property
  def translate(object); end
  include ThinkingSphinx::Core::Field
end
class ThinkingSphinx::RealTime::Index::Template
  def add_attribute(column, name, type, options = nil); end
  def add_field(column, name); end
  def apply; end
  def class_column; end
  def index; end
  def initialize(index); end
  def primary_key; end
end
class ThinkingSphinx::RealTime::Index < Riddle::Configuration::RealtimeIndex
  def add_attribute(attribute); end
  def add_field(field); end
  def append_unique_attribute(collection, attribute); end
  def attributes; end
  def attributes=(arg0); end
  def collection_for(attribute); end
  def conditions; end
  def conditions=(arg0); end
  def definition_block=(arg0); end
  def facets; end
  def fields; end
  def fields=(arg0); end
  def initialize(reference, options = nil); end
  def interpreter; end
  def offset; end
  def pre_render; end
  def properties; end
  def reference; end
  def scope; end
  def scope=(arg0); end
  def unique_attribute_names; end
  include ThinkingSphinx::Core::Index
end
class ThinkingSphinx::RealTime::Interpreter < ThinkingSphinx::Core::Interpreter
  def append_sortable_attributes(columns, options); end
  def has(*columns); end
  def indexes(*columns); end
  def scope(&block); end
  def set_property(properties); end
  def where(condition); end
end
class ThinkingSphinx::RealTime::Populator
  def batch_size(*args, &block); end
  def configuration; end
  def controller(*args, &block); end
  def index; end
  def initialize(index); end
  def instrument(message, options = nil); end
  def populate(&block); end
  def scope(*args, &block); end
  def self.populate(index); end
  def transcriber; end
end
class ThinkingSphinx::RealTime::TranscribeInstance
  def call; end
  def document_id; end
  def index; end
  def initialize(instance, index, properties); end
  def instance; end
  def properties; end
  def raise_wrapper(error, property); end
  def self.call(instance, index, properties); end
end
class ThinkingSphinx::RealTime::Transcriber
  def columns; end
  def copy(*instances); end
  def copy?(instance); end
  def index; end
  def initialize(index); end
  def instrument(message, options = nil); end
  def properties; end
end
class ThinkingSphinx::RealTime::Translator
  def call; end
  def column; end
  def initialize(object, column); end
  def name; end
  def object; end
  def owner; end
  def result; end
  def self.call(object, column); end
  def stack; end
end
class ThinkingSphinx::RealTime::Callbacks::RealTimeCallbacks
  def after_commit(instance); end
  def after_save(instance); end
  def block; end
  def callbacks_enabled?; end
  def configuration; end
  def indices; end
  def initialize(reference, path = nil, &block); end
  def objects_for(instance); end
  def path; end
  def persist_changes(instance); end
  def real_time_indices; end
  def real_time_indices?; end
  def reference; end
end
module ThinkingSphinx::RealTime
  def self.callback_for(reference, path = nil, &block); end
end
module ThinkingSphinx::RealTime::Callbacks
end
class ThinkingSphinx::Railtie < Rails::Railtie
end
module ThinkingSphinx::Hooks
end
module ThinkingSphinx::IndexingStrategies
end
module ThinkingSphinx::Subscribers
end
