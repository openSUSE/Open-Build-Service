# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/bunny-mock/all/bunny-mock.rbi
#
# bunny-mock-1.7.0
module BunnyMock
  def self.new(*arg0); end
  def self.protocol_version; end
  def self.use_bunny_queue_pop_api; end
  def self.use_bunny_queue_pop_api=(arg0); end
  def self.version; end
end
class BunnyMock::GetResponse
  def [](k); end
  def channel; end
  def delivery_tag; end
  def each(*args, &block); end
  def exchange; end
  def initialize(channel, queue, opts = nil); end
  def inspect; end
  def queue; end
  def redelivered; end
  def redelivered?; end
  def routing_key; end
  def self.next_delivery_tag; end
  def to_hash; end
  def to_s; end
  include Enumerable
end
class BunnyMock::MessageProperties
  def [](key); end
  def app_id; end
  def cluster_id; end
  def content_encoding; end
  def content_type; end
  def correlation_id; end
  def delivery_mode; end
  def each(*args, &block); end
  def expiration; end
  def headers; end
  def initialize(properties); end
  def inspect; end
  def message_id; end
  def priority; end
  def reply_to; end
  def timestamp; end
  def to_hash; end
  def to_s; end
  def type; end
  def user_id; end
  include Enumerable
end
class BunnyMock::Session
  def channel(n = nil, _pool_size = nil, *_args); end
  def close; end
  def closed?; end
  def closing?; end
  def connected?; end
  def create_channel(n = nil, _pool_size = nil, *_args); end
  def deregister_exchange(xchg); end
  def deregister_queue(queue); end
  def exchange_exists?(name); end
  def exchanges; end
  def find_exchange(name); end
  def find_queue(name); end
  def initialize(*arg0); end
  def open?; end
  def queue_exists?(name); end
  def queues; end
  def register_exchange(xchg); end
  def register_queue(queue); end
  def start; end
  def status; end
  def stop; end
  def with_channel(n = nil); end
end
class BunnyMock::Channel
  def ack(delivery_tag, multiple = nil); end
  def acknowledge(delivery_tag, multiple = nil); end
  def acknowledged_state; end
  def basic_publish(payload, xchg, routing_key, opts = nil); end
  def close; end
  def closed?; end
  def confirm_select(callback = nil); end
  def connection; end
  def default_exchange; end
  def deregister_exchange(xchg); end
  def deregister_queue(queue); end
  def direct(name, opts = nil); end
  def exchange(name, opts = nil); end
  def fanout(name, opts = nil); end
  def generate_consumer_tag(name = nil); end
  def header(name, opts = nil); end
  def id; end
  def initialize(connection = nil, id = nil); end
  def inspect; end
  def nack(delivery_tag, multiple = nil, requeue = nil); end
  def open; end
  def open?; end
  def prefetch(*arg0); end
  def queue(name = nil, opts = nil); end
  def queue_bind(queue, key, xchg); end
  def queue_unbind(queue, key, xchg); end
  def reject(delivery_tag, requeue = nil); end
  def status; end
  def temporary_queue(opts = nil); end
  def to_s; end
  def topic(name, opts = nil); end
  def update_acknowledgement_state(delivery_tag, new_state); end
  def wait_for_confirms(*arg0); end
  def xchg_bind(receiver, routing_key, name); end
  def xchg_bound_to?(receiver, key, name); end
  def xchg_find_or_create(name, opts = nil); end
  def xchg_routes_to?(queue, key, xchg); end
  def xchg_unbind(routing_key, name, exchange); end
end
class BunnyMock::Exchange
  def add_route(key, xchg_or_queue); end
  def arguments; end
  def auto_delete; end
  def auto_delete?; end
  def bind(exchange, opts = nil); end
  def bound_to?(exchange, opts = nil); end
  def channel; end
  def delete(*arg0); end
  def deleted; end
  def deliver(payload, opts, key); end
  def durable; end
  def durable?; end
  def has_binding?(exchange_or_queue, opts = nil); end
  def initialize(channel, name, type, opts); end
  def internal; end
  def internal?; end
  def name; end
  def opts; end
  def publish(payload, opts = nil); end
  def remove_route(key, xchg_or_queue); end
  def routes_to?(exchange_or_queue, opts = nil); end
  def self.declare(channel, name = nil, opts = nil); end
  def type; end
  def unbind(exchange, opts = nil); end
end
class BunnyMock::Queue
  def all; end
  def bind(exchange, opts = nil); end
  def bound_to?(exchange, opts = nil); end
  def bunny_pop(*arg0); end
  def channel; end
  def check_queue_deleted!; end
  def delete; end
  def get(opts = nil, &block); end
  def initialize(channel, name = nil, opts = nil); end
  def message_count; end
  def name; end
  def opts; end
  def pop(opts = nil, &block); end
  def pop_response(message); end
  def publish(payload, opts = nil); end
  def purge; end
  def store_acknowledgement(response, args); end
  def subscribe(*args, &block); end
  def subscribe_with(consumer, *args); end
  def unbind(exchange, opts = nil); end
  def yield_consumers; end
end
module BunnyMock::Exchanges
end
class BunnyMock::Exchanges::Direct < BunnyMock::Exchange
  def deliver(payload, opts, key); end
end
class BunnyMock::Exchanges::Topic < BunnyMock::Exchange
  def deliver(payload, opts, key); end
  def route_to_regex(key); end
end
class BunnyMock::Exchanges::Fanout < BunnyMock::Exchange
  def deliver(payload, opts, _key); end
end
class BunnyMock::Exchanges::Header < BunnyMock::Exchange
  def deliver(payload, opts, key); end
end
