# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/haml_lint/all/haml_lint.rbi
#
# haml_lint-0.32.0
module HamlLint
end
module HamlLint::Exceptions
end
class HamlLint::Exceptions::ConfigurationError < StandardError
end
class HamlLint::Exceptions::InvalidCLIOption < StandardError
end
class HamlLint::Exceptions::InvalidFilePath < StandardError
end
class HamlLint::Exceptions::ParseError < Haml::SyntaxError
end
class HamlLint::Exceptions::NoLintersError < StandardError
end
class HamlLint::Exceptions::UnknownHamlVersion < StandardError
end
class HamlLint::Exceptions::UnknownSeverity < StandardError
end
class HamlLint::Configuration
  def ==(other); end
  def [](key); end
  def ensure_exclude_option_array_exists; end
  def ensure_linter_include_exclude_arrays_exist; end
  def ensure_linter_section_exists; end
  def ensure_linter_severity_valid; end
  def for_linter(linter); end
  def hash; end
  def initialize(options, file = nil); end
  def merge(config); end
  def resolve_requires; end
  def smart_merge(parent, child); end
  def validate; end
end
class HamlLint::ConfigurationLoader
  def self.default_configuration; end
  def self.default_path_to_config; end
  def self.load_applicable_config(config_file = nil, options = nil); end
  def self.load_file(file, context = nil); end
  def self.load_from_file(file); end
  def self.load_hash(hash); end
  def self.possible_config_files(directory); end
  def self.resolve(file, context); end
  def self.resolve_inheritance(config, context); end
end
class HamlLint::Adapter
  def self.detect_class; end
  def self.haml_version; end
end
class HamlLint::Adapter::Haml4 < HamlLint::Adapter
  def initialize(source, options = nil); end
  def parse(*args, &block); end
  def parser; end
  extend Forwardable
end
class HamlLint::Adapter::Haml5 < HamlLint::Adapter
  def initialize(source, options = nil); end
  def parse; end
  def parser; end
  def source; end
end
class HamlLint::Document
  def config; end
  def convert_tree(haml_node, parent = nil); end
  def file; end
  def initialize(source, options); end
  def process_encoding(source); end
  def process_source(source); end
  def process_tree(original_tree); end
  def source; end
  def source_lines; end
  def strip_frontmatter(source); end
  def tree; end
end
module HamlLint::HamlVisitor
  def node_name(node); end
  def safe_send(name, *args, &block); end
  def visit(node); end
  def visit_children(parent); end
end
class HamlLint::Lint
  def error?; end
  def filename; end
  def initialize(linter, filename, line, message, severity = nil); end
  def line; end
  def linter; end
  def message; end
  def severity; end
end
class HamlLint::NoSuchLinter < StandardError
end
module HamlLint::LinterRegistry
  def self.extract_linters_from(linter_names); end
  def self.included(subclass); end
  def self.linters; end
end
class HamlLint::RubyParser
  def initialize; end
  def parse(source); end
end
class HamlLint::Linter
  def config; end
  def contains_interpolation?(string); end
  def document; end
  def following_node_line(node); end
  def initialize(config); end
  def inline_content_is_string?(node); end
  def inline_node_content(node); end
  def lints; end
  def name; end
  def next_node(node); end
  def parse_ruby(source); end
  def record_lint(node, message); end
  def run(document); end
  def strip_surrounding_quotes(string); end
  def tag_has_inline_script?(tag_node); end
  def tag_with_inline_text(tag_node); end
  include HamlLint::HamlVisitor
end
class HamlLint::Logger
  def bold(*args); end
  def bold_error(*args); end
  def color(code, output, newline = nil); end
  def color_enabled; end
  def color_enabled=(arg0); end
  def error(*args); end
  def info(*args); end
  def initialize(out, summary: nil); end
  def log(output, newline = nil); end
  def newline; end
  def self.silent; end
  def success(*args); end
  def summary_enabled; end
  def summary_enabled=(arg0); end
  def tty?; end
  def warning(*args); end
end
class HamlLint::Reporter
  def display_report(report); end
  def initialize(logger); end
  def log; end
  def self.available; end
  def self.available?; end
  def self.cli_name; end
  def self.descendants; end
  def self.inherited(descendant); end
  include HamlLint::Reporter::Hooks
end
module HamlLint::Reporter::Hooks
  def added_lint(_lint, _report); end
  def finished_file(_file, _lints); end
  def start(_files); end
end
class HamlLint::Report
  def add_lint(lint); end
  def display; end
  def fail_level; end
  def failed?; end
  def files; end
  def finish_file(file, lints); end
  def initialize(lints: nil, files: nil, fail_level: nil, reporter: nil); end
  def lints; end
  def lints=(arg0); end
  def start(files); end
end
class HamlLint::LinterSelector
  def extract_enabled_linters(config, options); end
  def initialize(config, options); end
  def linters_for_file(file); end
  def run_linter_on_file?(config, linter, file); end
end
class HamlLint::FileFinder
  def extract_files_from(patterns); end
  def find(patterns, excluded_patterns); end
  def haml_file?(file); end
  def initialize(config); end
  def normalize_path(path); end
end
class HamlLint::Runner
  def collect_lints(file, linter_selector, config); end
  def config; end
  def extract_applicable_files(config, options); end
  def fail_fast; end
  def fail_fast?; end
  def files; end
  def linter_selector; end
  def load_applicable_config(options); end
  def process_file(file, report); end
  def process_files(report); end
  def report(options); end
  def run(options = nil); end
end
module HamlLint::Utils
  def any_glob_matches?(globs_or_glob, file); end
  def camel_case(str); end
  def count_consecutive(items, offset = nil); end
  def extract_interpolated_values(text); end
  def extract_substring_positions(text, substr); end
  def for_consecutive_items(items, satisfies, min_consecutive = nil); end
  def get_abs_and_rel_path(path); end
  def self.any_glob_matches?(globs_or_glob, file); end
  def self.camel_case(str); end
  def self.count_consecutive(items, offset = nil); end
  def self.extract_interpolated_values(text); end
  def self.extract_substring_positions(text, substr); end
  def self.for_consecutive_items(items, satisfies, min_consecutive = nil); end
  def self.get_abs_and_rel_path(path); end
  def self.with_environment(env); end
  def with_environment(env); end
end
class HamlLint::Severity < SimpleDelegator
  def <=>(other); end
  def color; end
  def error?; end
  def initialize(name); end
  def level; end
  def mark; end
  def mark_with_color; end
  def name; end
  def warning?; end
  include Comparable
end
class HamlLint::CommentConfiguration
  def directives; end
  def directives_for(linter_name); end
  def disabled?(linter_name); end
  def initialize(node); end
end
module HamlLint::Tree
end
class HamlLint::Tree::Node
  def children; end
  def children=(arg0); end
  def comment_configuration; end
  def directives; end
  def disabled?(visitor); end
  def each; end
  def initialize(document, parse_node); end
  def inspect; end
  def line; end
  def line_numbers; end
  def lines; end
  def next_node; end
  def nontrivial_end_line; end
  def parent; end
  def parent=(arg0); end
  def predecessor; end
  def siblings; end
  def source_code; end
  def subsequents; end
  def successor; end
  def text; end
  def type; end
  include Enumerable
end
class HamlLint::Tree::Node::Siblings < SimpleDelegator
  def next(node); end
  def position(node); end
  def previous(node); end
  def priors(node); end
  def siblings; end
  def subsequents(node); end
end
class HamlLint::NodeTransformer
  def initialize(document); end
  def transform(haml_node); end
end
class HamlLint::Tree::CommentNode < HamlLint::Tree::Node
end
class HamlLint::Tree::DoctypeNode < HamlLint::Tree::Node
end
class HamlLint::Tree::FilterNode < HamlLint::Tree::Node
  def filter_type; end
end
class HamlLint::Directive
  def ==(other); end
  def disable?; end
  def enable?; end
  def initialize(source, line, mode, linters); end
  def inspect; end
  def linters; end
  def mode; end
  def self.from_line(source, line); end
end
class HamlLint::Directive::Null < HamlLint::Directive
  def disable?; end
  def enable?; end
  def initialize(source, line); end
  def inspect; end
  def linters; end
end
class HamlLint::Tree::HamlCommentNode < HamlLint::Tree::Node
  def contained_directives; end
  def directives; end
  def text; end
end
class HamlLint::Tree::NullNode < HamlLint::Tree::Node
  def disabled?(_linter); end
  def initialize(*_args); end
end
class HamlLint::Tree::PlainNode < HamlLint::Tree::Node
end
class HamlLint::Tree::RootNode < HamlLint::Tree::Node
  def file; end
  def node_for_line(line); end
end
class HamlLint::ParsedRuby < SimpleDelegator
  def contains_instance_variables?; end
  def syntax_tree; end
end
class HamlLint::Tree::ScriptNode < HamlLint::Tree::Node
  def parsed_script; end
  def script; end
end
class HamlLint::Tree::SilentScriptNode < HamlLint::Tree::Node
  def parsed_script; end
  def script; end
end
class HamlLint::Tree::TagNode < HamlLint::Tree::Node
  def attributes_source; end
  def contains_script?; end
  def dynamic_attributes_source; end
  def dynamic_attributes_sources; end
  def existing_attributes; end
  def has_hash_attribute?(attribute); end
  def hash_attributes?; end
  def hash_attributes_source; end
  def html_attributes?; end
  def html_attributes_source; end
  def object_reference?; end
  def object_reference_source; end
  def parsed_attributes; end
  def parsed_script; end
  def remove_inner_whitespace?; end
  def remove_outer_whitespace?; end
  def script; end
  def static_attributes_source; end
  def static_classes; end
  def static_ids; end
  def tag_id; end
  def tag_name; end
end
class HamlLint::Linter::AlignmentTabs < HamlLint::Linter
  def visit_tag(node); end
end
class HamlLint::Linter::AltText < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ClassAttributeWithStaticValue < HamlLint::Linter
  def contains_class_attribute?(attributes_sources); end
  def static_class_attribute_value?(pair); end
  def surrounded_by_braces?(code); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ClassesBeforeIds < HamlLint::Linter
  def attribute_prefix_order; end
  def attribute_type_order; end
  def enforced_style; end
  def ids_first?; end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ConsecutiveComments < HamlLint::Linter
  def possible_group(node); end
  def previously_reported?(node); end
  def reported_nodes; end
  def visit_haml_comment(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ConsecutiveSilentScripts < HamlLint::Linter
  def possible_group(node); end
  def previously_reported?(node); end
  def reported_nodes; end
  def visit_silent_script(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::EmptyObjectReference < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::EmptyScript < HamlLint::Linter
  def visit_silent_script(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::FinalNewline < HamlLint::Linter
  def visit_root(root); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::HtmlAttributes < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::IdNames < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ImplicitDiv < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::Indentation < HamlLint::Linter
  def check_character(character, root); end
  def check_width(width, root); end
  def visit_root(root); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::InlineStyles < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::InstanceVariables < HamlLint::Linter
  def enabled; end
  def enabled?; end
  def file_types; end
  def matcher; end
  def visit_root(node); end
  def visit_script(node); end
  def visit_silent_script(node); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::LeadingCommentSpace < HamlLint::Linter
  def visit_haml_comment(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::LineLength < HamlLint::Linter
  def visit_root(root); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::LineLength::DummyNode < Struct
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class HamlLint::Linter::MultilinePipe < HamlLint::Linter
  def check(node); end
  def line_text_for_node(node); end
  def visit_plain(node); end
  def visit_script(node); end
  def visit_silent_script(node); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::MultilineScript < HamlLint::Linter
  def check(node); end
  def visit_script(node); end
  def visit_silent_script(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ObjectReferenceAttributes < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::RepeatedId < HamlLint::Linter
  def add_lint(node, id); end
  def add_lints_for_first_duplications(nodes); end
  def id_map; end
  def visit_root(_node); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::RubyExtractor
  def add_dummy_puts(node, annotation = nil); end
  def add_line(code, node_or_line, discard_blanks = nil); end
  def after_visit_tag(node); end
  def anonymous_block?(text); end
  def block_keyword(text); end
  def check_tag_static_hash_source(node); end
  def extract(document); end
  def indent_code(code, indent); end
  def mid_block_keyword?(text); end
  def start_block_keyword?(text); end
  def visit_filter(node); end
  def visit_haml_comment(node); end
  def visit_plain(node); end
  def visit_root(_node); end
  def visit_script(node); end
  def visit_silent_script(node, &block); end
  def visit_tag(node); end
  include HamlLint::HamlVisitor
end
class HamlLint::RubyExtractor::RubySource < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source; end
  def source=(_); end
  def source_map; end
  def source_map=(_); end
end
class HamlLint::Linter::RuboCop < HamlLint::Linter
  def extract_lints_from_offenses(offenses, source_map); end
  def find_lints(ruby, source_map); end
  def lint_file(rubocop, file); end
  def record_lint(node, message, severity); end
  def rubocop_flags; end
  def visit_root(_node); end
  def with_ruby_from_stdin(ruby, &_block); end
  include HamlLint::LinterRegistry
end
class HamlLint::OffenseCollector < RuboCop::Formatter::BaseFormatter
  def file_finished(_file, offenses); end
  def self.offenses; end
  def self.offenses=(arg0); end
  def started(_target_files); end
end
class HamlLint::Linter::RubyComments < HamlLint::Linter
  def code_comment?(node); end
  def visit_silent_script(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::SpaceBeforeScript < HamlLint::Linter
  def missing_space?(node); end
  def visit_script(node); end
  def visit_silent_script(node); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::SpaceInsideHashAttributes < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::Syntax < HamlLint::Linter
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::TagName < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::TrailingWhitespace < HamlLint::Linter
  def visit_root(root); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::TrailingWhitespace::DummyNode < Struct
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class HamlLint::Linter::UnnecessaryInterpolation < HamlLint::Linter
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::UnnecessaryStringOutput < HamlLint::Linter
  def outputs_string_literal?(script_node); end
  def starts_with_reserved_character?(stringish); end
  def visit_script(node); end
  def visit_tag(node); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ViewLength < HamlLint::Linter
  def visit_root(root); end
  include HamlLint::LinterRegistry
end
class HamlLint::Linter::ViewLength::DummyNode < Struct
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class HamlLint::Reporter::CheckstyleReporter < HamlLint::Reporter
  def display_report(report); end
  def render_offenses(offenses); end
end
module HamlLint::Reporter::Utils
  def pluralize(word, count: nil); end
  def print_lint(lint); end
  def print_location(lint); end
  def print_message(lint); end
  def print_summary(report); end
  def print_summary_files(report); end
  def print_summary_lints(report); end
  def print_type(lint); end
end
class HamlLint::Reporter::DefaultReporter < HamlLint::Reporter
  def added_lint(lint, report); end
  def display_report(report); end
  include HamlLint::Reporter::Utils
end
class HamlLint::Reporter::ProgressReporter < HamlLint::Reporter
  def display_report(report); end
  def dot; end
  def finished_file(_file, lints); end
  def report_file_as_mark(lints); end
  def start(files); end
  include HamlLint::Reporter::Utils
end
class HamlLint::Reporter::DisabledConfigReporter < HamlLint::Reporter::ProgressReporter
  def config_file_contents; end
  def display_report(report); end
  def exclude_limit; end
  def finished_file(file, lints); end
  def generate_config_for_linter(linter, files); end
  def initialize(log, limit: nil); end
  def linters_lint_count; end
  def linters_with_lints; end
  def self.available?; end
end
class HamlLint::Reporter::HashReporter < HamlLint::Reporter
  def display_report(report); end
  def map_file(file); end
  def map_offense(offense); end
  def metadata; end
  def self.available?; end
end
class HamlLint::Reporter::JsonReporter < HamlLint::Reporter::HashReporter
  def display_report(report); end
  def self.available?; end
end
