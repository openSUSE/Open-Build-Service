# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/airbrake-ruby/all/airbrake-ruby.rbi
#
# airbrake-ruby-3.1.0
module Airbrake
  def self.[](notifier_name); end
  def self.add_filter(filter = nil, &block); end
  def self.build_notice(exception, params = nil); end
  def self.close; end
  def self.configure(notifier_name = nil); end
  def self.configured?; end
  def self.create_deploy(deploy_params); end
  def self.delete_filter(filter_class); end
  def self.merge_context(context); end
  def self.notify(exception, params = nil, &block); end
  def self.notify_request(request_info); end
  def self.notify_sync(exception, params = nil, &block); end
end
class Airbrake::Config
  def app_version; end
  def app_version=(arg0); end
  def blacklist_keys; end
  def blacklist_keys=(arg0); end
  def code_hunks; end
  def code_hunks=(arg0); end
  def endpoint; end
  def environment; end
  def environment=(arg0); end
  def host; end
  def host=(arg0); end
  def ignore_environments; end
  def ignore_environments=(arg0); end
  def ignored_environment?; end
  def initialize(user_config = nil); end
  def logger; end
  def logger=(logger); end
  def merge(config_hash); end
  def project_id; end
  def project_id=(arg0); end
  def project_key; end
  def project_key=(arg0); end
  def proxy; end
  def proxy=(arg0); end
  def queue_size; end
  def queue_size=(arg0); end
  def root_directory; end
  def root_directory=(arg0); end
  def route_stats; end
  def route_stats=(arg0); end
  def route_stats_flush_period; end
  def route_stats_flush_period=(arg0); end
  def set_option(option, value); end
  def timeout; end
  def timeout=(arg0); end
  def valid?; end
  def validation_error_message; end
  def versions; end
  def versions=(arg0); end
  def whitelist_keys; end
  def whitelist_keys=(arg0); end
  def workers; end
  def workers=(arg0); end
end
class Airbrake::Config::Validator
  def error_message; end
  def initialize(config); end
  def valid_environment?; end
  def valid_project_id?; end
  def valid_project_key?; end
end
class Airbrake::Promise
  def initialize; end
  def reject(error); end
  def rescue(&block); end
  def resolve(response); end
  def then(&block); end
  def value; end
end
class Airbrake::SyncSender
  def build_https(uri); end
  def build_request(uri, data); end
  def build_request_body(req, data); end
  def initialize(config, method = nil); end
  def missing_body?(req, promise); end
  def proxy_params; end
  def rate_limited_ip?(promise); end
  def send(data, promise, endpoint = nil); end
end
class Airbrake::AsyncSender
  def close; end
  def closed?; end
  def has_workers?; end
  def initialize(config); end
  def send(notice, promise); end
  def spawn_worker; end
  def spawn_workers; end
  def will_not_deliver(notice); end
end
module Airbrake::Response
  def self.parse(response, logger); end
  def self.rate_limit_reset(response); end
  def self.truncated_body(body); end
end
class Airbrake::NestedException
  def as_json; end
  def initialize(config, exception); end
  def unwind_exceptions; end
end
class Airbrake::Notice
  def [](key); end
  def []=(key, value); end
  def context; end
  def ignore!; end
  def ignored?; end
  def initialize(config, exception, params = nil); end
  def raise_if_ignored; end
  def stash; end
  def to_json; end
  def truncate; end
end
module Airbrake::Backtrace
  def self.best_regexp_for(exception); end
  def self.execjs_exception?(exception); end
  def self.frame_in_root?(frame, root_directory); end
  def self.java_exception?(exception); end
  def self.match_frame(regexp, stackframe); end
  def self.oci_exception?(exception); end
  def self.parse(config, exception); end
  def self.parse_backtrace(config, exception); end
  def self.populate_code(config, frame); end
  def self.stack_frame(config, regexp, stackframe); end
end
module Airbrake::Backtrace::Patterns
end
class Airbrake::Truncator
  def initialize(max_size); end
  def reduce_max_size; end
  def replace_invalid_characters(str); end
  def stringify_object(object); end
  def truncate(object, seen = nil); end
  def truncate_array(array, seen); end
  def truncate_hash(hash, seen); end
  def truncate_object(object, seen); end
  def truncate_set(set, seen); end
  def truncate_string(str); end
end
module Airbrake::Filters
end
module Airbrake::Filters::KeysFilter
  def call(notice); end
  def eval_proc_patterns!; end
  def filter_context_key(notice, key); end
  def filter_hash(hash); end
  def filter_url(notice); end
  def filter_url_params(url); end
  def initialize(logger, patterns); end
  def should_filter?(_key); end
  def validate_patterns; end
  def weight; end
end
class Airbrake::Filters::KeysWhitelist
  def initialize(*arg0); end
  def should_filter?(key); end
  include Airbrake::Filters::KeysFilter
end
class Airbrake::Filters::KeysBlacklist
  def initialize(*arg0); end
  def should_filter?(key); end
  include Airbrake::Filters::KeysFilter
end
class Airbrake::Filters::GemRootFilter
  def call(notice); end
  def initialize; end
  def weight; end
end
class Airbrake::Filters::SystemExitFilter
  def call(notice); end
  def initialize; end
  def weight; end
end
class Airbrake::Filters::RootDirectoryFilter
  def call(notice); end
  def initialize(root_directory); end
  def weight; end
end
class Airbrake::Filters::ThreadFilter
  def add_thread_info(th, thread_info); end
  def call(notice); end
  def fiber_variables(th); end
  def initialize; end
  def sanitize_value(value); end
  def thread_variables(th); end
  def weight; end
end
class Airbrake::Filters::ContextFilter
  def call(notice); end
  def initialize(context); end
  def weight; end
end
class Airbrake::Filters::ExceptionAttributesFilter
  def call(notice); end
  def initialize(logger); end
end
class Airbrake::Filters::DependencyFilter
  def call(notice); end
  def git_version(spec); end
  def initialize; end
end
class Airbrake::Filters::GitRevisionFilter
  def call(notice); end
  def find_from_packed_refs(head); end
  def find_revision; end
  def initialize(root_directory); end
  def weight; end
end
class Airbrake::Filters::GitRepositoryFilter
  def call(notice); end
  def initialize(root_directory); end
  def weight; end
end
class Airbrake::Filters::GitLastCheckoutFilter
  def call(notice); end
  def checkout_line?(line); end
  def initialize(logger, root_directory); end
  def last_checkout; end
  def last_checkout_line; end
  def timestamp(utime); end
  def weight; end
end
class Airbrake::FilterChain
  def add_default_filters; end
  def add_filter(filter); end
  def delete_filter(filter_class); end
  def initialize(config, context); end
  def inspect; end
  def pretty_print(q); end
  def refine(notice); end
end
class Airbrake::Notifier
  def add_filter(filter = nil, &block); end
  def build_notice(exception, params = nil); end
  def clean_backtrace; end
  def close; end
  def configured?; end
  def convert_to_exception(ex); end
  def create_deploy(deploy_params); end
  def default_sender; end
  def delete_filter(filter_class); end
  def initialize(user_config); end
  def inspect; end
  def merge_context(context); end
  def notify(exception, params = nil, &block); end
  def notify_request(request_info); end
  def notify_sync(exception, params = nil, &block); end
  def pretty_print(q); end
  def send_notice(exception, params, sender); end
end
class Airbrake::CodeHunk
  def get(file, line); end
  def get_from_cache(file); end
  def get_lines(file, start_line, end_line); end
  def initialize(config); end
end
module Airbrake::FileCache
  def self.[](key); end
  def self.[]=(key, value); end
  def self.data; end
  def self.empty?; end
end
class Airbrake::RouteSender
  def create_route_key(method, route, status_code, tm); end
  def increment_stats(request_info, stat); end
  def initialize(config); end
  def notify_request(request_info, promise = nil); end
  def schedule_flush(promise); end
  def send(routes, promise); end
  def utc_truncate_minutes(time); end
end
module Airbrake::RouteSender::TDigestBigEndianness
end
class Airbrake::RouteSender::RouteKey < Struct
  def method; end
  def method=(_); end
  def route; end
  def route=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def statusCode; end
  def statusCode=(_); end
  def time; end
  def time=(_); end
end
class Airbrake::RouteSender::RouteStat < Struct
  def count; end
  def count=(_); end
  def initialize(count: nil, sum: nil, sumsq: nil, tdigest: nil); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sum; end
  def sum=(_); end
  def sumsq; end
  def sumsq=(_); end
  def tdigest; end
  def tdigest=(_); end
  def to_h; end
end
class Airbrake::Error < StandardError
end
class Airbrake::NilNotifier
  def add_filter(_filter = nil, &_block); end
  def build_notice(_exception, _params = nil); end
  def close; end
  def configured?; end
  def create_deploy(_deploy_params); end
  def delete_filter(_filter_class); end
  def merge_context(_context); end
  def notify(_exception, _params = nil, &block); end
  def notify_request(_request_info); end
  def notify_sync(_exception, _params = nil, &block); end
end
