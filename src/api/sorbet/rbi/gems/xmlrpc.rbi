# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/xmlrpc/all/xmlrpc.rbi
#
# xmlrpc-0.3.0
module XMLRPC
  def self.iPIMethods(prefix); end
  def self.interface(prefix, &p); end
end
class XMLRPC::Base64
  def decoded; end
  def encoded; end
  def initialize(str, state = nil); end
  def self.decode(str); end
  def self.encode(str); end
end
class XMLRPC::DateTime
  def ==(o); end
  def day; end
  def day=(value); end
  def hour; end
  def hour=(value); end
  def initialize(year, month, day, hour, min, sec); end
  def min; end
  def min=(value); end
  def mon; end
  def mon=(value); end
  def month; end
  def month=(value); end
  def sec; end
  def sec=(value); end
  def to_a; end
  def to_date; end
  def to_time; end
  def year; end
  def year=(value); end
end
class XMLRPC::FaultException < StandardError
  def faultCode; end
  def faultString; end
  def initialize(faultCode, faultString); end
  def to_h; end
end
module XMLRPC::Convert
  def self.base64(str); end
  def self.boolean(str); end
  def self.dateTime(str); end
  def self.double(str); end
  def self.fault(hash); end
  def self.int(str); end
  def self.struct(hash); end
end
module XMLRPC::XMLParser
  def self.each_installed_parser; end
end
class XMLRPC::XMLParser::AbstractTreeParser
  def array(node); end
  def assert(b); end
  def base64(node); end
  def boolean(node); end
  def data(node); end
  def dateTime(node); end
  def double(node); end
  def fault(node); end
  def hasOnlyOneChild(node, name = nil); end
  def integer(node); end
  def member(node); end
  def methodCall(node); end
  def methodName(node); end
  def methodResponse(node); end
  def name(node); end
  def nodeMustBe(node, name); end
  def param(node); end
  def params(node, call = nil); end
  def parseMethodCall(str); end
  def parseMethodResponse(str); end
  def removeWhitespacesAndComments(node); end
  def string(node); end
  def struct(node); end
  def text(node); end
  def text_zero_one(node); end
  def v_nil(node); end
  def value(node); end
end
class XMLRPC::XMLParser::AbstractStreamParser
  def parseMethodCall(str); end
  def parseMethodResponse(str); end
end
module XMLRPC::XMLParser::StreamParserMixin
  def character(data); end
  def endElement(name); end
  def fault; end
  def initialize(*a); end
  def method_name; end
  def params; end
  def startElement(name, attrs = nil); end
end
class XMLRPC::XMLParser::REXMLStreamParser < XMLRPC::XMLParser::AbstractStreamParser
  def initialize; end
end
class XMLRPC::XMLParser::REXMLStreamParser::StreamListener
  def cdata(data); end
  def method_missing(*a); end
  def parse(str); end
  def tag_end(name); end
  def tag_start(name, attrs = nil); end
  def text(data); end
  include XMLRPC::XMLParser::StreamParserMixin
end
class XMLRPC::XMLParser::LibXMLStreamParser < XMLRPC::XMLParser::AbstractStreamParser
  def initialize; end
end
class XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener
  def method_missing(*a); end
  def on_cdata_block(data); end
  def on_characters(data); end
  def on_end_element_ns(name, prefix, uri); end
  def on_start_element_ns(name, attributes, prefix, uri, namespaces); end
  def parse(str); end
  include XMLRPC::XMLParser::StreamParserMixin
end
module XMLRPC::XMLWriter
  def self.each_installed_writer; end
end
class XMLRPC::XMLWriter::Abstract
  def ele(name, *children); end
  def tag(name, txt); end
end
class XMLRPC::XMLWriter::Simple < XMLRPC::XMLWriter::Abstract
  def document(*params); end
  def document_to_str(doc); end
  def element(name, attrs, *children); end
  def pi(name, *params); end
  def text(txt); end
end
class XMLRPC::XMLWriter::XMLParser < XMLRPC::XMLWriter::Abstract
  def document(*params); end
  def document_to_str(doc); end
  def element(name, attrs, *children); end
  def initialize; end
  def pi(name, *params); end
  def text(txt); end
end
class XMLRPC::Create
  def conv2value(param); end
  def initialize(xml_writer = nil); end
  def methodCall(name, *params); end
  def methodResponse(is_ret, *params); end
  def wrong_type(value); end
end
module XMLRPC::Config
end
module XMLRPC::Marshallable
end
module XMLRPC::ParserWriterChooseMixin
  def create; end
  def parser; end
  def set_parser(parser); end
  def set_writer(writer); end
end
module XMLRPC::Service
end
class XMLRPC::Service::BasicInterface
  def add_method(sig, help = nil, meth_name = nil); end
  def initialize(prefix); end
  def methods; end
  def parse_sig(sig); end
  def prefix; end
end
class XMLRPC::Service::Interface < XMLRPC::Service::BasicInterface
  def get_methods(obj, delim = nil); end
  def initialize(prefix, &p); end
  def meth(*a); end
end
class XMLRPC::Service::PublicInstanceMethodsInterface < XMLRPC::Service::BasicInterface
  def get_methods(obj, delim = nil); end
  def initialize(prefix); end
end
module XMLRPC::ParseContentType
  def parse_content_type(str); end
end
class XMLRPC::Client
  def call(method, *args); end
  def call2(method, *args); end
  def call2_async(method, *args); end
  def call_async(method, *args); end
  def cookie; end
  def cookie=(arg0); end
  def do_rpc(request, async = nil); end
  def dup_net_http; end
  def gen_multicall(methods = nil, async = nil); end
  def http; end
  def http_header_extra; end
  def http_header_extra=(arg0); end
  def http_last_response; end
  def initialize(host = nil, path = nil, port = nil, proxy_host = nil, proxy_port = nil, user = nil, password = nil, use_ssl = nil, timeout = nil); end
  def multicall(*methods); end
  def multicall2(*methods); end
  def multicall2_async(*methods); end
  def multicall_async(*methods); end
  def net_http(host, port, proxy_host, proxy_port); end
  def parse_set_cookies(set_cookies); end
  def password; end
  def password=(new_password); end
  def proxy(prefix = nil, *args); end
  def proxy2(prefix = nil, *args); end
  def proxy2_async(prefix = nil, *args); end
  def proxy_async(prefix = nil, *args); end
  def self.new2(uri, proxy = nil, timeout = nil); end
  def self.new3(hash = nil); end
  def self.new_from_hash(hash = nil); end
  def self.new_from_uri(uri, proxy = nil, timeout = nil); end
  def set_auth; end
  def timeout; end
  def timeout=(new_timeout); end
  def user; end
  def user=(new_user); end
  include XMLRPC::ParseContentType
  include XMLRPC::ParserWriterChooseMixin
end
class XMLRPC::Client::Proxy
  def initialize(server, prefix, args = nil, meth = nil, delim = nil); end
  def method_missing(mid, *args); end
end
