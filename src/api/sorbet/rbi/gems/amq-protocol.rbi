# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/amq-protocol/all/amq-protocol.rbi
#
# amq-protocol-2.3.0
module AMQ
end
module AMQ::Endianness
  def big_endian?; end
  def little_endian?; end
  extend AMQ::Endianness
end
module AMQ::Pack
  def self.pack_int16_big_endian(short); end
  def self.pack_uint64_big_endian(long_long); end
  def self.unpack_int16_big_endian(data); end
  def self.unpack_uint64_big_endian(data); end
end
module AMQ::Protocol
  def self.classes; end
  def self.methods; end
end
module AMQ::Protocol::TypeConstants
end
class AMQ::Protocol::Float32Bit
  def initialize(value); end
  def value; end
end
class AMQ::Protocol::TableValueEncoder
  def self.array_size(value); end
  def self.encode(value); end
  def self.field_value_size(value); end
  include AMQ::Protocol::TypeConstants
end
class AMQ::Protocol::TableValueDecoder
  def self.decode_32bit_float(data, offset); end
  def self.decode_64bit_float(data, offset); end
  def self.decode_array(data, initial_offset); end
  def self.decode_big_decimal(data, offset); end
  def self.decode_boolean(data, offset); end
  def self.decode_byte(data, offset); end
  def self.decode_hash(data, offset); end
  def self.decode_integer(data, offset); end
  def self.decode_long(data, offset); end
  def self.decode_short(data, offset); end
  def self.decode_string(data, offset); end
  def self.decode_time(data, offset); end
  def self.decode_value_type(data, offset); end
  include AMQ::Protocol::TypeConstants
end
class AMQ::Protocol::Table
  def self.decode(data); end
  def self.decode_table_key(data, offset); end
  def self.encode(table); end
  def self.hash_size(value); end
  def self.length(data); end
  include AMQ::Protocol::TypeConstants
end
class AMQ::Protocol::Table::InvalidTableError < StandardError
  def initialize(key, value); end
end
class AMQ::Protocol::Frame
  def final?; end
  def self.__new__(*arg0); end
  def self.decode(*arg0); end
  def self.decode_header(header); end
  def self.encode(type, payload, channel); end
  def self.encode_to_array(type, payload, channel); end
  def self.encoded_payload(payload); end
  def self.find_type(type); end
  def self.new(original_type, *args); end
end
class AMQ::Protocol::FrameSubclass < AMQ::Protocol::Frame
  def channel; end
  def channel=(arg0); end
  def encode; end
  def encode_to_array; end
  def initialize(payload, channel); end
  def payload; end
  def self.encode(payload, channel); end
  def self.id; end
  def self.new(*arg0); end
  def size; end
end
class AMQ::Protocol::MethodFrame < AMQ::Protocol::FrameSubclass
  def decode_payload; end
  def final?; end
  def method_class; end
end
class AMQ::Protocol::HeaderFrame < AMQ::Protocol::FrameSubclass
  def body_size; end
  def decode_payload; end
  def final?; end
  def klass_id; end
  def properties; end
  def weight; end
end
class AMQ::Protocol::BodyFrame < AMQ::Protocol::FrameSubclass
  def decode_payload; end
  def final?; end
end
class AMQ::Protocol::HeartbeatFrame < AMQ::Protocol::FrameSubclass
  def final?; end
  def self.encode; end
end
class AMQ::Protocol::Error < StandardError
  def initialize(message = nil); end
  def self.[](code); end
  def self.inherited(subclass); end
  def self.subclasses_with_values; end
end
class AMQ::Protocol::FrameTypeError < AMQ::Protocol::Error
  def initialize(types); end
end
class AMQ::Protocol::EmptyResponseError < AMQ::Protocol::Error
  def initialize(message = nil); end
end
class AMQ::Protocol::BadResponseError < AMQ::Protocol::Error
  def initialize(argument, expected, actual); end
end
class AMQ::Protocol::SoftError < AMQ::Protocol::Error
  def self.inherited(subclass); end
end
class AMQ::Protocol::HardError < AMQ::Protocol::Error
  def self.inherited(subclass); end
end
class AMQ::Protocol::ContentTooLarge < AMQ::Protocol::SoftError
end
class AMQ::Protocol::NoRoute < AMQ::Protocol::SoftError
end
class AMQ::Protocol::NoConsumers < AMQ::Protocol::SoftError
end
class AMQ::Protocol::AccessRefused < AMQ::Protocol::SoftError
end
class AMQ::Protocol::NotFound < AMQ::Protocol::SoftError
end
class AMQ::Protocol::ResourceLocked < AMQ::Protocol::SoftError
end
class AMQ::Protocol::PreconditionFailed < AMQ::Protocol::SoftError
end
class AMQ::Protocol::ConnectionForced < AMQ::Protocol::HardError
end
class AMQ::Protocol::InvalidPath < AMQ::Protocol::HardError
end
class AMQ::Protocol::FrameError < AMQ::Protocol::HardError
end
class AMQ::Protocol::SyntaxError < AMQ::Protocol::HardError
end
class AMQ::Protocol::CommandInvalid < AMQ::Protocol::HardError
end
class AMQ::Protocol::ChannelError < AMQ::Protocol::HardError
end
class AMQ::Protocol::UnexpectedFrame < AMQ::Protocol::HardError
end
class AMQ::Protocol::ResourceError < AMQ::Protocol::HardError
end
class AMQ::Protocol::NotAllowed < AMQ::Protocol::HardError
end
class AMQ::Protocol::NotImplemented < AMQ::Protocol::HardError
end
class AMQ::Protocol::InternalError < AMQ::Protocol::HardError
end
class AMQ::Protocol::Class
  def self.classes; end
  def self.inherited(base); end
  def self.method_id; end
  def self.name; end
end
class AMQ::Protocol::Method
  def self.encode_body(body, channel, frame_size); end
  def self.index; end
  def self.inherited(base); end
  def self.instantiate(*args, &block); end
  def self.method_id; end
  def self.methods; end
  def self.name; end
  def self.split_headers(user_headers); end
end
class AMQ::Protocol::Connection < AMQ::Protocol::Class
end
class AMQ::Protocol::Connection::Start < AMQ::Protocol::Method
  def initialize(version_major, version_minor, server_properties, mechanisms, locales); end
  def locales; end
  def mechanisms; end
  def self.decode(data); end
  def self.has_content?; end
  def server_properties; end
  def version_major; end
  def version_minor; end
end
class AMQ::Protocol::Connection::StartOk < AMQ::Protocol::Method
  def self.encode(client_properties, mechanism, response, locale); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Secure < AMQ::Protocol::Method
  def challenge; end
  def initialize(challenge); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::SecureOk < AMQ::Protocol::Method
  def self.encode(response); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Tune < AMQ::Protocol::Method
  def channel_max; end
  def frame_max; end
  def heartbeat; end
  def initialize(channel_max, frame_max, heartbeat); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::TuneOk < AMQ::Protocol::Method
  def self.encode(channel_max, frame_max, heartbeat); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Open < AMQ::Protocol::Method
  def self.encode(virtual_host); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::OpenOk < AMQ::Protocol::Method
  def initialize(known_hosts); end
  def known_hosts; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Close < AMQ::Protocol::Method
  def class_id; end
  def initialize(reply_code, reply_text, class_id, method_id); end
  def method_id; end
  def reply_code; end
  def reply_text; end
  def self.decode(data); end
  def self.encode(reply_code, reply_text, class_id, method_id); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::CloseOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.encode; end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Blocked < AMQ::Protocol::Method
  def initialize(reason); end
  def reason; end
  def self.decode(data); end
  def self.encode(reason); end
  def self.has_content?; end
end
class AMQ::Protocol::Connection::Unblocked < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.encode; end
  def self.has_content?; end
end
class AMQ::Protocol::Channel < AMQ::Protocol::Class
end
class AMQ::Protocol::Channel::Open < AMQ::Protocol::Method
  def self.encode(channel, out_of_band); end
  def self.has_content?; end
end
class AMQ::Protocol::Channel::OpenOk < AMQ::Protocol::Method
  def channel_id; end
  def initialize(channel_id); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Channel::Flow < AMQ::Protocol::Method
  def active; end
  def initialize(active); end
  def self.decode(data); end
  def self.encode(channel, active); end
  def self.has_content?; end
end
class AMQ::Protocol::Channel::FlowOk < AMQ::Protocol::Method
  def active; end
  def initialize(active); end
  def self.decode(data); end
  def self.encode(channel, active); end
  def self.has_content?; end
end
class AMQ::Protocol::Channel::Close < AMQ::Protocol::Method
  def class_id; end
  def initialize(reply_code, reply_text, class_id, method_id); end
  def method_id; end
  def reply_code; end
  def reply_text; end
  def self.decode(data); end
  def self.encode(channel, reply_code, reply_text, class_id, method_id); end
  def self.has_content?; end
end
class AMQ::Protocol::Channel::CloseOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.encode(channel); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange < AMQ::Protocol::Class
end
class AMQ::Protocol::Exchange::Declare < AMQ::Protocol::Method
  def self.encode(channel, exchange, type, passive, durable, auto_delete, internal, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::DeclareOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::Delete < AMQ::Protocol::Method
  def self.encode(channel, exchange, if_unused, nowait); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::DeleteOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::Bind < AMQ::Protocol::Method
  def self.encode(channel, destination, source, routing_key, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::BindOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::Unbind < AMQ::Protocol::Method
  def self.encode(channel, destination, source, routing_key, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Exchange::UnbindOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue < AMQ::Protocol::Class
end
class AMQ::Protocol::Queue::Declare < AMQ::Protocol::Method
  def self.encode(channel, queue, passive, durable, exclusive, auto_delete, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::DeclareOk < AMQ::Protocol::Method
  def consumer_count; end
  def initialize(queue, message_count, consumer_count); end
  def message_count; end
  def queue; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::Bind < AMQ::Protocol::Method
  def self.encode(channel, queue, exchange, routing_key, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::BindOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::Purge < AMQ::Protocol::Method
  def self.encode(channel, queue, nowait); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::PurgeOk < AMQ::Protocol::Method
  def initialize(message_count); end
  def message_count; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::Delete < AMQ::Protocol::Method
  def self.encode(channel, queue, if_unused, if_empty, nowait); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::DeleteOk < AMQ::Protocol::Method
  def initialize(message_count); end
  def message_count; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::Unbind < AMQ::Protocol::Method
  def self.encode(channel, queue, exchange, routing_key, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Queue::UnbindOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic < AMQ::Protocol::Class
  def self.decode_properties(data); end
  def self.encode_app_id(value); end
  def self.encode_cluster_id(value); end
  def self.encode_content_encoding(value); end
  def self.encode_content_type(value); end
  def self.encode_correlation_id(value); end
  def self.encode_delivery_mode(value); end
  def self.encode_expiration(value); end
  def self.encode_headers(value); end
  def self.encode_message_id(value); end
  def self.encode_priority(value); end
  def self.encode_properties(body_size, properties); end
  def self.encode_reply_to(value); end
  def self.encode_timestamp(value); end
  def self.encode_type(value); end
  def self.encode_user_id(value); end
end
class AMQ::Protocol::Basic::Qos < AMQ::Protocol::Method
  def self.encode(channel, prefetch_size, prefetch_count, global); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::QosOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Consume < AMQ::Protocol::Method
  def self.encode(channel, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::ConsumeOk < AMQ::Protocol::Method
  def consumer_tag; end
  def initialize(consumer_tag); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Cancel < AMQ::Protocol::Method
  def consumer_tag; end
  def initialize(consumer_tag, nowait); end
  def nowait; end
  def self.decode(data); end
  def self.encode(channel, consumer_tag, nowait); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::CancelOk < AMQ::Protocol::Method
  def consumer_tag; end
  def initialize(consumer_tag); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Publish < AMQ::Protocol::Method
  def self.encode(channel, payload, user_headers, exchange, routing_key, mandatory, immediate, frame_size); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Return < AMQ::Protocol::Method
  def exchange; end
  def initialize(reply_code, reply_text, exchange, routing_key); end
  def reply_code; end
  def reply_text; end
  def routing_key; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Deliver < AMQ::Protocol::Method
  def consumer_tag; end
  def delivery_tag; end
  def exchange; end
  def initialize(consumer_tag, delivery_tag, redelivered, exchange, routing_key); end
  def redelivered; end
  def routing_key; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Get < AMQ::Protocol::Method
  def self.encode(channel, queue, no_ack); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::GetOk < AMQ::Protocol::Method
  def delivery_tag; end
  def exchange; end
  def initialize(delivery_tag, redelivered, exchange, routing_key, message_count); end
  def message_count; end
  def redelivered; end
  def routing_key; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::GetEmpty < AMQ::Protocol::Method
  def cluster_id; end
  def initialize(cluster_id); end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Ack < AMQ::Protocol::Method
  def delivery_tag; end
  def initialize(delivery_tag, multiple); end
  def multiple; end
  def self.decode(data); end
  def self.encode(channel, delivery_tag, multiple); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Reject < AMQ::Protocol::Method
  def self.encode(channel, delivery_tag, requeue); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::RecoverAsync < AMQ::Protocol::Method
  def self.encode(channel, requeue); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Recover < AMQ::Protocol::Method
  def self.encode(channel, requeue); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::RecoverOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Basic::Nack < AMQ::Protocol::Method
  def delivery_tag; end
  def initialize(delivery_tag, multiple, requeue); end
  def multiple; end
  def requeue; end
  def self.decode(data); end
  def self.encode(channel, delivery_tag, multiple, requeue); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx < AMQ::Protocol::Class
end
class AMQ::Protocol::Tx::Select < AMQ::Protocol::Method
  def self.encode(channel); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx::SelectOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx::Commit < AMQ::Protocol::Method
  def self.encode(channel); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx::CommitOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx::Rollback < AMQ::Protocol::Method
  def self.encode(channel); end
  def self.has_content?; end
end
class AMQ::Protocol::Tx::RollbackOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.has_content?; end
end
class AMQ::Protocol::Confirm < AMQ::Protocol::Class
end
class AMQ::Protocol::Confirm::Select < AMQ::Protocol::Method
  def initialize(nowait); end
  def nowait; end
  def self.decode(data); end
  def self.encode(channel, nowait); end
  def self.has_content?; end
end
class AMQ::Protocol::Confirm::SelectOk < AMQ::Protocol::Method
  def initialize; end
  def self.decode(data); end
  def self.encode(channel); end
  def self.has_content?; end
end
class AMQ::BitSet
  def [](i); end
  def check_range(i); end
  def clear; end
  def get(i); end
  def init_words(nbits); end
  def initialize(nbits); end
  def next_clear_bit; end
  def self.number_of_trailing_ones(num); end
  def set(i); end
  def to_s; end
  def unset(i); end
  def word_index(i); end
  def words_in_use; end
end
class AMQ::IntAllocator
  def allocate; end
  def allocated?(reservation); end
  def free(reservation); end
  def hi; end
  def initialize(lo, hi); end
  def lo; end
  def number_of_bits; end
  def release(reservation); end
  def reset; end
end
class AMQ::URI
  def self.as_boolean(val); end
  def self.parse(connection_string); end
  def self.parse_amqp_url(s); end
end
module AMQ::Settings
  def self.configure(settings = nil); end
  def self.default; end
  def self.parse_amqp_url(connection_string); end
end
