# a Patchinfo lives in a Project, but is not a package - it represents a special package
class Patchinfo

  class ReleasetargetNotFound < APIException
    setup 404
  end

  def verify_data(project, raw_post)
    data = ActiveXML::Node.new(raw_post)
    if data and data.packager
      # bugzilla only knows email adresses, so we support automatic conversion
      if data.packager.to_s.include? '@'
        packager = User.find_by_login data.packager
        #FIXME: update _patchinfo file
      end
      packager = User.get_by_login data.packager.to_s unless packager
    end
    # are releasetargets specified ? validate that this project is actually defining them.
    if data and data.releasetarget
      data.each_releasetarget do |rt|
        found = false
        project.repositories.each do |r|
          r.release_targets.each do |prt|
            if rt.repository
              found = true if prt.target_repository.project.name == rt.project and prt.target_repository.name == rt.repository
            else
              found = true if prt.target_repository.project.name == rt.project
            end
          end
        end

        unless found
          raise ReleasetargetNotFound.new "Release target '#{rt.project}/#{rt.repository}' is not defined in this project '#{project.name}'"
        end
      end
    end
  end

  def update_patchinfo(project, patchinfo, opts = {})
    project.check_write_access!

    opts[:enfore_issue_update] ||= false

    # collect bugnumbers from diff
    project.packages.each do |p|
      # create diff per package
      next if p.package_kinds.find_by_kind 'patchinfo'

      p.package_issues.each do |i|
        if i.change == "added"
          unless patchinfo.has_element?("issue[(@id='#{i.issue.name}' and @tracker='#{i.issue.issue_tracker.name}')]")
            e = patchinfo.add_element "issue"
            e.set_attribute "tracker", i.issue.issue_tracker.name
            e.set_attribute "id", i.issue.name
            patchinfo.category.text = "security" if i.issue.issue_tracker.kind == "cve"
          end
        end
      end
    end

    # update informations of empty issues
    patchinfo.each_issue do |i|
      if i.text.blank? and not i.name.blank?
        issue = Issue.find_or_create_by_name_and_tracker(i.name, i.tracker)
        if issue
          if opts[:enfore_issue_update]
            # enforce update from issue server
            issue.fetch_updates()
          end
          i.text = issue.summary
        end
      end
    end

    return patchinfo
  end

  def create_patchinfo_from_request(project, req)
    project.check_write_access!

    patchinfo = Package.new(:name => "patchinfo", :title => "Patchinfo", :description => "Collected packages for update")
    project.packages << patchinfo
    patchinfo.add_flag("build", "enable", nil, nil)
    patchinfo.add_flag("useforbuild", "disable", nil, nil)
    patchinfo.add_flag("publish", "enable", nil, nil) unless project.flags.find_by_flag_and_status("access", "disable")
    patchinfo.store

    # create patchinfo XML file
    node = Nokogiri::XML::Builder.new
    attrs = {}
    if project.project_type.to_s == "maintenance_incident"
      # this is a maintenance incident project, the sub project name is the maintenance ID
      attrs[:incident] = project.name.gsub(/.*:/, '')
    end

    description = req.description || ''
    node.patchinfo(attrs) do |n|
      n.packager req.creator
      n.category "recommended" # update_patchinfo may switch to security
      n.rating "low"
      n.summary description.split(/\n|\r\n/)[0] # first line only
      n.description req.description
    end
    data = ActiveXML::Node.new(node.doc.to_xml)
    data = self.update_patchinfo(project, data, enfore_issue_update: true)
    p = {:user => User.current.login, :comment => "generated by request id #{req.id} accept call"}
    patchinfo_path = "/source/#{CGI.escape(patchinfo.project.name)}/patchinfo/_patchinfo"
    patchinfo_path << Suse::Backend.build_query_from_hash(p, [:user, :comment])
    Suse::Backend.put(patchinfo_path, data.dump_xml)
    patchinfo.sources_changed
  end

  class PatchinfoFileExists < APIException;
  end
  class PackageAlreadyExists < APIException;
  end

  def create_patchinfo(project, pkg_name, opts = {})
    pkg_name ||= "patchinfo"
    valid_package_name! pkg_name

    # create patchinfo package
    pkg = nil
    if Package.exists_by_project_and_name(project, pkg_name)
      pkg = Package.get_by_project_and_name project, pkg_name
      unless opts[:force]
        if pkg.package_kinds.find_by_kind 'patchinfo'
          raise PatchinfoFileExists.new "createpatchinfo command: the patchinfo #{pkg_name} exists already. Either use force=1 re-create the _patchinfo or use updatepatchinfo for updating."
        else
          raise PackageAlreadyExists.new "createpatchinfo command: the package #{pkg_name} exists already, but is  no patchinfo. Please create a new package instead."
        end
        return
      end
    else
      prj = Project.get_by_name(project)
      pkg = Package.new(name: pkg_name, title: "Patchinfo", description: "Collected packages for update")
      prj.packages << pkg
      pkg.add_flag("build", "enable", nil, nil)
      pkg.add_flag("publish", "enable", nil, nil) unless prj.flags.find_by_flag_and_status("access", "disable")
      pkg.add_flag("useforbuild", "disable", nil, nil)
      pkg.store
    end

    # create patchinfo XML file
    node = Builder::XmlMarkup.new(:indent => 2)
    attrs = {}
    if pkg.project.project_type == "maintenance_incident"
      # this is a maintenance incident project, the sub project name is the maintenance ID
      attrs[:incident] = pkg.project.name.gsub(/.*:/, '')
    end
    xml = node.patchinfo(attrs) do |n|
      node.packager User.current.login
      node.category "recommended"
      node.rating "low"
      node.summary opts[:comment]
      node.description ""
    end
    xml = ActiveXML::Node.new(node.target!)
    xml = self.update_patchinfo(pkg.project, xml)
    p={:user => User.current.login, :comment => "generated by createpatchinfo call"}
    patchinfo_path = "/source/#{CGI.escape(pkg.project.name)}/#{CGI.escape(pkg.name)}/_patchinfo"
    patchinfo_path << Suse::Backend.build_query_from_hash(p, [:user, :comment])
    Suse::Backend.put(patchinfo_path, xml.dump_xml)
    pkg.sources_changed
    return {:targetproject => pkg.project.name, :targetpackage => pkg_name}
  end

  def cmd_update_patchinfo(project, package)
    pkg = Package.get_by_project_and_name project, package

    # get existing file
    patchinfo_path = "/source/#{URI.escape(pkg.project.name)}/#{URI.escape(pkg.name)}/_patchinfo"
    xml = ActiveXML::Node.new(ActiveXML.transport.direct_http(patchinfo_path))
    xml = self.update_patchinfo(pkg.project, xml)

    p={:user => User.current.login, :comment => "updated via updatepatchinfo call"}
    patchinfo_path = "/source/#{URI.escape(pkg.project.name)}/#{URI.escape(pkg.name)}/_patchinfo"
    patchinfo_path << Suse::Backend.build_query_from_hash(p, [:user, :comment])
    Suse::Backend.put(patchinfo_path, xml.dump_xml)
    pkg.sources_changed

  end

  class IncompletePatchinfo < APIException;
  end

  def fetch_release_targets(pkg)
    answer = Suse::Backend.get("/source/#{URI.escape(pkg.project.name)}/#{URI.escape(pkg.name)}/_patchinfo")
    data = ActiveXML::Node.new(answer.body)
    # validate _patchinfo for completeness
    unless data
      raise IncompletePatchinfo.new "The _patchinfo file is not parseble"
    end
    if data.rating.nil? or data.rating.text.blank?
      raise IncompletePatchinfo.new "The _patchinfo has no rating set"
    end
    if data.category.nil? or data.category.text.blank?
      raise IncompletePatchinfo.new "The _patchinfo has no category set"
    end
    if data.summary.nil? or data.summary.text.blank?
      raise IncompletePatchinfo.new "The _patchinfo has no summary set"
    end
    # a patchinfo may limit the targets
    if data.releasetarget
      releaseTargets = Array.new unless releaseTargets
      data.each_releasetarget do |rt|
        releaseTargets << rt
      end
    end
  end
end